<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[如何统计一个页面所有元素]]></title>
      <url>http://yoursite.com/2016/12/17/js-8/</url>
      <content type="html"><![CDATA[<h3 id="源自贺老的live"><a href="#源自贺老的live" class="headerlink" title="源自贺老的live"></a>源自贺老的live</h3><p>如何统计一个页面所有的元素？</p>
<ul>
<li>getElementsByTagName(“*”)<br>获得一个<a href="http://www.html-js.com/article/1619" target="_blank" rel="external">类数组对象</a>，然后进行去重。</li>
<li>querySelectorAll(“*”)<br>同上。</li>
<li>黑科技<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Set</span>($$(<span class="string">"*"</span>).map(<span class="function"><span class="params">e</span> =&gt;</span> e.tagName)).size;</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HackerRank小问题汇总]]></title>
      <url>http://yoursite.com/2016/11/22/js-7/</url>
      <content type="html"><![CDATA[<h4 id="A-Very-Big-Sum"><a href="#A-Very-Big-Sum" class="headerlink" title="A Very Big Sum"></a>A Very Big Sum</h4><p>You are given an array of integers of size N. You need to print the sum of the elements in the array, keeping in mind that some of those integers may be quite large.<br><a id="more"></a><br>Input Format</p>
<p>The first line of the input consists of an integer N. The next line contains  space-separated integers contained in the array.</p>
<p>Output Format</p>
<p>Print a single value equal to the sum of the elements in the array.</p>
<p>Sample Input</p>
<p>5<br>1000000001 1000000002 1000000003 1000000004 1000000005</p>
<p>Output</p>
<p>5000000015</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES6</span></div><div class="line"><span class="built_in">console</span>.log(arr.reduce(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> prev + curr));</div><div class="line"><span class="comment">//ES5</span></div><div class="line"><span class="built_in">console</span>.log(arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev,cur</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> prev+cur;</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<h4 id="D11"><a href="#D11" class="headerlink" title="D11"></a>D11</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sum = sum.sort(<span class="function"><span class="keyword">function</span>(<span class="params">val1,val2</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> val1 - val2;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(sum[<span class="number">15</span>]); <span class="comment">//[ 0, 2, 3, 3, 4, 4, 6, 6, 7, 7, 8, 8, 9, 10, 14, 19 ]</span></div><div class="line"><span class="comment">//如果这样写，会被当成字符串处理，不知道为什么。</span></div><div class="line">sum = sum.sort();</div><div class="line"><span class="built_in">console</span>.log(sum);<span class="comment">//[ 0, 10, 14, 19, 2, 3, 3, 4, 4, 6, 6, 7, 7, 8, 8, 9 ]</span></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js数组去重备忘]]></title>
      <url>http://yoursite.com/2016/11/16/js-6/</url>
      <content type="html"><![CDATA[<p>一、<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> res = [];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</div><div class="line">	<span class="keyword">if</span>(arr.indexOf(arr[i]) == i)&#123;</div><div class="line">		res.push(arr[i]);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(res);</div></pre></td></tr></table></figure></p>
<p>二、<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> res = [];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</div><div class="line">	<span class="keyword">if</span>(res.indexOf(arr[i]) == <span class="number">-1</span>)&#123;</div><div class="line">		res.push(arr[i]);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(res);</div></pre></td></tr></table></figure></p>
<p>三、<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>];</div><div class="line">arr = arr.sort();</div><div class="line"><span class="keyword">var</span> res =[arr[<span class="number">0</span>]];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</div><div class="line">	<span class="keyword">if</span>( arr[i] !== res[res.length<span class="number">-1</span>])</div><div class="line">	&#123;</div><div class="line">		res.push(arr[i]);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(res);</div></pre></td></tr></table></figure></p>
<p>四、<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> hash = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> res = [];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</div><div class="line">	<span class="keyword">var</span> item = arr[i];</div><div class="line">    <span class="keyword">var</span> key = <span class="keyword">typeof</span>(item) + item;<span class="comment">//区分字符串一和数字一</span></div><div class="line">    <span class="keyword">if</span> (hash[key] !== <span class="number">1</span>) &#123;</div><div class="line">      res.push(item);</div><div class="line">      hash[key] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(res);</div></pre></td></tr></table></figure></p>
<p><a href="http://sentsin.com/web/63.html" target="_blank" rel="external">玉伯的博客</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HackerRank-Algorithms爬行记录]]></title>
      <url>http://yoursite.com/2016/11/12/HackerRank-Algorithms%E7%88%AC%E8%A1%8C%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h4 id="ACM-ICPC-Team"><a href="#ACM-ICPC-Team" class="headerlink" title="ACM ICPC Team"></a>ACM ICPC Team</h4><p>You are given a list of N people who are attending ACM-ICPC World Finals. Each of them are either well versed in a topic or they are not. Find out the maximum number of topics a 2-person team can know. And also find out how many teams can know that maximum number of topics.</p>
<a id="more"></a>
<p>Note Suppose a, b, and c are three different people, then (a,b) and (b,c) are counted as two different teams.</p>
<p>Input Format</p>
<p>The first line contains two integers,N and M, separated by a single space, where  represents the number of N people, and M represents the number of topics. N lines follow.<br>Each line contains a binary string of length . If the ith line’s jth character is 1, then the ith person knows the jth topic; otherwise, he doesn’t know the topic.</p>
<p>Constraints </p>
<p>Output Format</p>
<p>On the first line, print the maximum number of topics a 2-person team can know.<br>On the second line, print the number of 2-person teams that can know the maximum number of topics.</p>
<p>Sample Input</p>
<p>4 5<br>10101<br>11100<br>11010<br>00101</p>
<p>Sample Output</p>
<p>5<br>2</p>
<p>Explanation</p>
<p>(1, 3) and (3, 4) know all the 5 topics. So the maximal topics a 2-person team knows is 5, and only 2 teams can achieve this.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> n_temp = readLine().split(<span class="string">' '</span>);</div><div class="line">    <span class="keyword">var</span> n = <span class="built_in">parseInt</span>(n_temp[<span class="number">0</span>]);</div><div class="line">    <span class="keyword">var</span> m = <span class="built_in">parseInt</span>(n_temp[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">var</span> topic = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> topic_i = <span class="number">0</span>; topic_i &lt; n; topic_i++)&#123;</div><div class="line">       topic[topic_i] = readLine();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> max_topic = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> max_team = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> k = i + <span class="number">1</span>;k &lt; n;k++)&#123;</div><div class="line">            <span class="keyword">var</span> team_topic = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>;j &lt; m;j++)&#123;</div><div class="line">                <span class="keyword">if</span>((topic[i][j] + topic[k][j])&gt;=<span class="number">1</span>)&#123;</div><div class="line">                    team_topic++;</div><div class="line">                &#125;</div><div class="line">            &#125;            </div><div class="line">            <span class="keyword">if</span>(team_topic == max_topic)&#123;</div><div class="line">                max_team ++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(team_topic &gt; max_topic)&#123;</div><div class="line">                max_team = <span class="number">1</span>;</div><div class="line">                max_topic = team_topic;</div><div class="line">            &#125;           </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(max_topic);</div><div class="line">    <span class="built_in">console</span>.log(max_team);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Bigger-is-Greater"><a href="#Bigger-is-Greater" class="headerlink" title="Bigger is Greater"></a>Bigger is Greater</h4><p>Given a word w, rearrange the letters of w to construct another word s in such a way that s is lexicographically greater than w. In case of multiple possible answers, find the lexicographically smallest one among them.</p>
<p>Output Format</p>
<p>For each testcase, output a string lexicographically bigger than  in a separate line. In case of multiple possible answers, print the lexicographically smallest one, and if no answer exists, print no answer.</p>
<p>Sample Input</p>
<p>5<br>ab<br>bb<br>hefg<br>dhck<br>dkhc</p>
<p>Sample Output</p>
<p>ba<br>no answer<br>hegf<br>dhkc<br>hcdk</p>
<p>Explanation</p>
<p>Test case 1:<br>There exists only one string greater than ab which can be built by rearranging ab. That is ba.<br>Test case 2:<br>Not possible to rearrange bb and get a lexicographically greater string.<br>Test case 3:<br>hegf is the next string lexicographically greater than hefg.<br>Test case 4:<br>dhkc is the next string lexicographically greater than dhck.<br>Test case 5:<br>hcdk is the next string lexicographically greater than dkhc.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//思路是全排列然后排序打印input后一位的字符串，如果最后一位为input则输出no answer</span></div><div class="line"><span class="comment">//通过了case 0，但是后面的case全挂了，因为溢出和timeout。。</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processData</span>(<span class="params">input</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> Arr = input.split(<span class="string">""</span>);</div><div class="line">    resultList = [];</div><div class="line">    Permutation(Arr,<span class="number">0</span>,Arr.length<span class="number">-1</span>);</div><div class="line">    resultList = resultList.sort();</div><div class="line">    index = resultList.indexOf(input);</div><div class="line">    </div><div class="line">    <span class="built_in">console</span>.log((resultList[resultList.length<span class="number">-1</span>] == input)?<span class="string">"no answer"</span>:resultList[index+<span class="number">1</span>]);</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Permutation</span>(<span class="params">Arr, m, n</span>) </span>&#123;  </div><div class="line">    <span class="keyword">if</span>(m == n)  &#123;  </div><div class="line">        <span class="keyword">var</span> result = Arr.join(<span class="string">""</span>);</div><div class="line">        resultList.push(result);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = m;i &lt;= n;i++)&#123;     </div><div class="line">            <span class="keyword">var</span> temp = Arr[i];</div><div class="line">            Arr[i] = Arr[m];</div><div class="line">            Arr[m] = temp;   </div><div class="line">            Permutation(Arr,m + <span class="number">1</span>,n);   </div><div class="line">            <span class="keyword">var</span> temp = Arr[m];</div><div class="line">            Arr[m] = Arr[i];</div><div class="line">            Arr[i] = temp;   </div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">process.stdin.resume();</div><div class="line">process.stdin.setEncoding(<span class="string">"ascii"</span>);</div><div class="line">_input = <span class="string">""</span>;</div><div class="line">process.stdin.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">input</span>) </span>&#123;</div><div class="line">    _input += input;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">process.stdin.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    _input = _input.split(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">var</span> n = _input[<span class="number">0</span>];</div><div class="line">    _input = _input.slice(<span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</div><div class="line">        processData(_input[i]);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><a href="https://www.nayuki.io/page/next-lexicographical-permutation-algorithm" target="_blank" rel="external">Next lexicographical permutation algorithm</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processData</span>(<span class="params">input</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> array = input.split(<span class="string">""</span>);</div><div class="line">    <span class="keyword">var</span> i = array.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; array[i - <span class="number">1</span>] &gt;= array[i])</div><div class="line">        i--;</div><div class="line">    <span class="comment">// Now i is the head index of the suffix</span></div><div class="line">    </div><div class="line">    <span class="comment">// Are we at the last permutation already?</span></div><div class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"no answer"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Let array[i - 1] be the pivot</span></div><div class="line">    <span class="comment">// Find rightmost element that exceeds the pivot</span></div><div class="line">    <span class="keyword">var</span> j = array.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (array[j] &lt;= array[i - <span class="number">1</span>])</div><div class="line">        j--;</div><div class="line">    <span class="comment">// Now the value array[j] will become the new pivot</span></div><div class="line">    <span class="comment">// Assertion: j &gt;= i</span></div><div class="line">    </div><div class="line">    <span class="comment">// Swap the pivot with j</span></div><div class="line">    <span class="keyword">var</span> temp = array[i - <span class="number">1</span>];</div><div class="line">    array[i - <span class="number">1</span>] = array[j];</div><div class="line">    array[j] = temp;</div><div class="line">    </div><div class="line">    <span class="comment">// Reverse the suffix</span></div><div class="line">    j = array.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</div><div class="line">        <span class="keyword">var</span> temp = array[i];</div><div class="line">        array[i] = array[j];</div><div class="line">        array[j] = temp;</div><div class="line">        i++;</div><div class="line">        j--;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Successfully computed the next permutation</span></div><div class="line">    <span class="built_in">console</span>.log(array.join(<span class="string">""</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line">process.stdin.resume();</div><div class="line">process.stdin.setEncoding(<span class="string">"ascii"</span>);</div><div class="line">_input = <span class="string">""</span>;</div><div class="line">process.stdin.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">input</span>) </span>&#123;</div><div class="line">    _input += input;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">process.stdin.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    _input = _input.split(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">var</span> n = _input[<span class="number">0</span>];</div><div class="line">    _input = _input.slice(<span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</div><div class="line">        processData(_input[i]);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HackerRank-LinkList爬行记录]]></title>
      <url>http://yoursite.com/2016/11/12/HackerRank-LinkList%E7%88%AC%E8%A1%8C%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h4 id="Print-the-Elements-of-a-Linked-List"><a href="#Print-the-Elements-of-a-Linked-List" class="headerlink" title="Print the Elements of a Linked List"></a>Print the Elements of a Linked List</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Print(Node *head)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span>(head!=NULL) &#123;</div><div class="line">        cout &lt;&lt; head-&gt;data &lt;&lt; endl; </div><div class="line">        head=head-&gt;next; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="Insert-a-Node-at-the-Tail-of-a-Linked-List"><a href="#Insert-a-Node-at-the-Tail-of-a-Linked-List" class="headerlink" title="Insert a Node at the Tail of a Linked List"></a>Insert a Node at the Tail of a Linked List</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Node* Insert(Node *head,int data)</div><div class="line">&#123;</div><div class="line">	Node *temp=<span class="keyword">new</span> Node();</div><div class="line">	temp-&gt;data = data;</div><div class="line">	temp-&gt;next = NULL;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(head == NULL)&#123;</div><div class="line">  		head = temp;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">  		Node *p;</div><div class="line">  		p = head;</div><div class="line">  		<span class="keyword">while</span>(p-&gt;next != NULL)</div><div class="line">      	p = p-&gt;next;</div><div class="line">  		p-&gt;next = temp;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span>(head);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Insert-a-node-at-the-head-of-a-linked-list"><a href="#Insert-a-node-at-the-head-of-a-linked-list" class="headerlink" title="Insert a node at the head of a linked list"></a>Insert a node at the head of a linked list</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Node* Insert(Node *head,int data)</div><div class="line">&#123;</div><div class="line">  <span class="comment">// Complete this method</span></div><div class="line">    Node *cur = <span class="keyword">new</span> Node;</div><div class="line">    <span class="keyword">if</span>(head==NULL)&#123;</div><div class="line">        cur-&gt;data = data;</div><div class="line">        cur-&gt;next = NULL;</div><div class="line">        <span class="keyword">return</span> cur;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        cur-&gt;data = data;</div><div class="line">        cur-&gt;next = head;</div><div class="line">        head = cur;</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Insert-a-node-at-a-specific-position-in-a-linked-list"><a href="#Insert-a-node-at-a-specific-position-in-a-linked-list" class="headerlink" title="Insert a node at a specific position in a linked list"></a>Insert a node at a specific position in a linked list</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Node* InsertNth(Node *head, int data, int position)</div><div class="line">&#123;</div><div class="line">    Node \*newNode = (Node*)malloc(sizeof(Node));</div><div class="line">    newNode-&gt;data = data;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (head == NULL) &#123;</div><div class="line">        <span class="keyword">return</span> newNode;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (position == <span class="number">0</span>) &#123;</div><div class="line">       newNode-&gt;next = head;</div><div class="line">       <span class="keyword">return</span> newNode;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Node *currentNode = head;</div><div class="line">    <span class="keyword">while</span> (position - <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</div><div class="line">        currentNode = currentNode-&gt;next;</div><div class="line">        position--;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    newNode-&gt;next = currentNode-&gt;next;</div><div class="line">    currentNode-&gt;next = newNode;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> head;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h4 id="Delete-a-Node"><a href="#Delete-a-Node" class="headerlink" title="Delete a Node"></a>Delete a Node</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Node* Delete(Node *head, int position)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(head == NULL)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(position == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    Node *cur;</div><div class="line">    cur = head;</div><div class="line">    <span class="keyword">while</span>(position - <span class="number">1</span> &gt; <span class="number">0</span>)&#123;</div><div class="line">        cur = cur-&gt;next;</div><div class="line">        position--;</div><div class="line">    &#125;</div><div class="line">    Node *p = <span class="keyword">new</span> Node;</div><div class="line">    p = cur-&gt;next;</div><div class="line">    cur-&gt;next = p-&gt;next;</div><div class="line">    free(p);</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Print-in-Reverse"><a href="#Print-in-Reverse" class="headerlink" title="Print in Reverse"></a>Print in Reverse</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//递归</span></div><div class="line"><span class="keyword">void</span> ReversePrint(Node *head)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(head == NULL)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        ReversePrint(head-&gt;next);</div><div class="line">        cout &lt;&lt; head-&gt;data &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Reverse-a-linked-list"><a href="#Reverse-a-linked-list" class="headerlink" title="Reverse a linked list"></a>Reverse a linked list</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Node* Reverse(Node *head)</div><div class="line">&#123;</div><div class="line">    Node *cur, *prev, *next;</div><div class="line">    prev = NULL;</div><div class="line">    cur = head;</div><div class="line">    next = head-&gt;next;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(head==NULL)&#123;</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(cur-&gt;next)&#123;</div><div class="line">        cur-&gt;next = prev;</div><div class="line">        prev = cur;</div><div class="line">        cur = next;</div><div class="line">        next = next-&gt;next;</div><div class="line">    &#125;</div><div class="line">    cur-&gt;next = prev;</div><div class="line">    head = cur;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Compare-two-linked-lists"><a href="#Compare-two-linked-lists" class="headerlink" title="Compare two linked lists"></a>Compare two linked lists</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">int CompareLists(Node *headA, Node* headB)</div><div class="line">&#123;</div><div class="line">  <span class="comment">// This is a "method-only" submission. </span></div><div class="line">  <span class="comment">// You only need to complete this method </span></div><div class="line">    <span class="keyword">while</span> (headA &amp;&amp; headB &amp;&amp; (headA-&gt;data == headB-&gt;data)) &#123;</div><div class="line">        headA = headA-&gt;next;</div><div class="line">        headB = headB-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> headA == headB;</div><div class="line">&#125;</div><div class="line"><span class="comment">//递归版本</span></div><div class="line">int CompareLists(Node headA, Node headB) &#123;</div><div class="line">    <span class="keyword">if</span> (headA == <span class="literal">null</span> &amp;&amp; headB == <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span> || headA.data != headB.data) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> CompareLists(headA.next, headB.next);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Merge-two-sorted-linked-lists"><a href="#Merge-two-sorted-linked-lists" class="headerlink" title="Merge two sorted linked lists"></a>Merge two sorted linked lists</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">Node* MergeLists(Node *headA, Node* headB)</div><div class="line">&#123;</div><div class="line">  <span class="comment">// This is a "method-only" submission. </span></div><div class="line">  <span class="comment">// You only need to complete this method </span></div><div class="line">    <span class="keyword">if</span>(!headA)&#123;<span class="keyword">return</span> headB;&#125;</div><div class="line">    <span class="keyword">if</span>(!headB)&#123;<span class="keyword">return</span> headA;&#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(headA-&gt;data &lt; headB-&gt;data)&#123;</div><div class="line">        headA-&gt;next = MergeLists(headA-&gt;next,headB);</div><div class="line">        <span class="keyword">return</span> headA;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        headB-&gt;next = MergeLists(headA,headB-&gt;next);</div><div class="line">        <span class="keyword">return</span> headB;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//非递归</span></div><div class="line">Node* MergeLists(Node *headA, Node* headB)</div><div class="line">&#123;</div><div class="line">  <span class="comment">// This is a "method-only" submission. </span></div><div class="line">  <span class="comment">// You only need to complete this method </span></div><div class="line">    <span class="keyword">if</span>(headA==NULL)</div><div class="line">        <span class="keyword">return</span> headB;</div><div class="line">    <span class="keyword">if</span>(headB==NULL)</div><div class="line">        <span class="keyword">return</span> headA;</div><div class="line">    Node *head,*curr;</div><div class="line">    <span class="keyword">if</span>(headA-&gt;data&lt;headB-&gt;data)&#123;</div><div class="line">        head=headA;</div><div class="line">        headA=headA-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        head=headB;</div><div class="line">        headB=headB-&gt;next;</div><div class="line">    &#125;</div><div class="line">    curr=head;</div><div class="line">    <span class="keyword">while</span>(headA&amp;&amp;headB)&#123;</div><div class="line">        <span class="keyword">if</span>(headA-&gt;data&lt;headB-&gt;data)&#123;</div><div class="line">            curr-&gt;next=headA;</div><div class="line">            headA=headA-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            curr-&gt;next=headB;</div><div class="line">            headB=headB-&gt;next;</div><div class="line">        &#125;</div><div class="line">        curr=curr-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(headA)&#123;</div><div class="line">        curr-&gt;next=headA;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        curr-&gt;next=headB;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js引用类型--RegExp]]></title>
      <url>http://yoursite.com/2016/11/05/js-5/</url>
      <content type="html"><![CDATA[<h3 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h3><p>ECMAScript 通过RegExp 类型来支持正则表达式。使用下面类似Perl 的语法，就可以创建一个正<br>则表达式。<br>var expression = / pattern / flags ;<br>pattern部分可以是任意正则表达式，其中遇到元字符需要转义，可以带一个或多个标志。</p>
<ul>
<li>g 全局，并非一经匹配马上停止</li>
<li>i 忽略大小写</li>
<li>m 多行匹配</li>
</ul>
<a id="more"></a>
<h4 id="一些实例属性"><a href="#一些实例属性" class="headerlink" title="一些实例属性"></a>一些实例属性</h4><ul>
<li>global 是否设置了g标志</li>
<li>ignoreCase 是否设置了i标志</li>
<li>lastIndex 开始搜索下一个匹配项的字符位置</li>
<li>multiline 是否设置了m标志</li>
<li>source 正则表达式的字符串表示</li>
</ul>
<p>其实这些属性没有多大用处，因为可以直接从正则里看。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/\\[bc\\]at/i</span>; </div><div class="line">alert(pattern1.global); <span class="comment">//false</span></div><div class="line">alert(pattern1.ignoreCase); <span class="comment">//true</span></div><div class="line">alert(pattern1.multiline); <span class="comment">//false</span></div><div class="line">alert(pattern1.lastIndex); <span class="comment">//0</span></div><div class="line">alert(pattern1.source); <span class="comment">//"\\[bc\\]at"</span></div></pre></td></tr></table></figure></p>
<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><h5 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h5><p>RegExp 对象的主要方法是exec()，该方法是专门为捕获组而设计的。exec()接受一个参数，即<br>要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。<br>返回的数组虽然是Array 的实例，但包含两个额外的属性：index 和input。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"mom and dad and baby"</span>;</div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</div><div class="line"><span class="keyword">var</span> matches = pattern.exec(text);</div><div class="line"><span class="built_in">console</span>.log(matches);</div><div class="line"><span class="comment">//["mom and dad and baby", " and dad and baby", " and baby", index: 0, input: "mom and dad and baby"]</span></div></pre></td></tr></table></figure></p>
<p>这个例子中的模式包含两个捕获组。最内部的捕获组匹配”and baby”，而包含它的捕获组匹配”and dad”或者”and dad and baby”。当把字符串传入exec()方法中之后，发现了一个匹配项。因为整个字符串本身与模式匹配，所以返回的数组matchs 的index 属性值为0。数组中的第一项是匹配的整个字符串，第二项包含与第一个捕获组匹配的内容，第三项包含与第二个捕获组匹配的内容。<br>对于exec()来说，即使设置了/g，每次也只返回<strong>一项</strong>匹配，多次调用返回多项。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pattern2 = <span class="regexp">/.at/g</span>;</div><div class="line"><span class="keyword">var</span> matches = pattern2.exec(text);</div><div class="line">alert(matches.index); <span class="comment">//0</span></div><div class="line">alert(matches[<span class="number">0</span>]); <span class="comment">//cat</span></div><div class="line">alert(pattern2.lastIndex); <span class="comment">//3</span></div><div class="line"></div><div class="line">matches = pattern2.exec(text);</div><div class="line">alert(matches.index); <span class="comment">//5</span></div><div class="line">alert(matches[<span class="number">0</span>]); <span class="comment">//bat</span></div><div class="line">alert(pattern2.lastIndex); <span class="comment">//8</span></div></pre></td></tr></table></figure></p>
<h5 id="test"><a href="#test" class="headerlink" title="test()"></a>test()</h5><p>它接受一个字符串参数。在模式与该参数匹配的情况下返回true；否则，返回false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便。因此，test()方法经常被用在if 语句中，如下面的例子所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"000-00-0000"</span>;</div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>;</div><div class="line"><span class="keyword">if</span> (pattern.test(text))&#123;</div><div class="line">	alert(<span class="string">"The pattern was matched."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>test()方法常用于验证用户输入是否符合规范。</p>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>比如toLocaleString()和toString()方法，返回正则表达式的字面量。<br>valueOf()则返回自身。<br>match方法不知道为什么没写，同exec()返回的也是数组，但是执行的是全局匹配。</p>
<h4 id="一些常用的正则表达式（持续更新）"><a href="#一些常用的正则表达式（持续更新）" class="headerlink" title="一些常用的正则表达式（持续更新）"></a>一些常用的正则表达式（持续更新）</h4><p>实现replaceAll()方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceAll</span>(<span class="params">str</span>)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(str != <span class="literal">null</span>)</div><div class="line">	str = str.replace(<span class="regexp">/word/g</span>,<span class="string">"Excel"</span>)</div><div class="line">	<span class="keyword">return</span> str;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(replaceAll(<span class="string">"wordwordwordword"</span>));</div></pre></td></tr></table></figure></p>
<p>邮箱验证的正则<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//加号表示匹配一个或多个在它之前的字符</span></div><div class="line"><span class="keyword">var</span> p = <span class="regexp">/^([a-zA-z0-9/-])+@([a-zA-Z0-9/-])+(.[a-zA-Z0-9/-])+/</span></div><div class="line"><span class="built_in">console</span>.log(p.test(<span class="string">"usey95@qq.com"</span>)); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(p.test(<span class="string">"usey95"</span>)); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>验证手机号的正则<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="regexp">/^1[3|5|8][0-9]\d&#123;4,8&#125;$/</span>;</div><div class="line"><span class="built_in">console</span>.log(p.test(<span class="string">"13055556666"</span>)); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(p.test(<span class="string">"23055556666"</span>)); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[11/3一些悬而未决的小问题]]></title>
      <url>http://yoursite.com/2016/11/03/work-6/</url>
      <content type="html"><![CDATA[<p>对一个数组Array = [2,1,3,[2,1,3[2,1,3]]]，进行排序，我觉得我笔试的时候应该是写对了的，但是昨天面试官问我的时候没有底气仔细看。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">Array</span> = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]]];</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">		a.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">			<span class="keyword">if</span>(item <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</div><div class="line">				fun(item);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		<span class="keyword">return</span> a.sort();</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">console</span>.log(fun(<span class="built_in">Array</span>));</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>对一个字符串进行首字母大写操作。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">"hello world"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> arr = str.split(<span class="string">" "</span>);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; arr.length;i++)</div><div class="line">	&#123;</div><div class="line">		arr[i] = arr[i].replace(arr[i][<span class="number">0</span>],arr[i][<span class="number">0</span>].toUpperCase());</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> arr.join(<span class="string">" "</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(change(s)); <span class="comment">//Hello World</span></div></pre></td></tr></table></figure></p>
<p>positon属性列举：<a href="http://www.w3school.com.cn/cssref/pr_class_position.asp" target="_blank" rel="external">w3c</a></p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>absolute</td>
<td>生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td>
</tr>
<tr>
<td>fixed</td>
<td>生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td>
</tr>
<tr>
<td>relative</td>
<td>生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</td>
</tr>
<tr>
<td>static    默认值。</td>
<td>没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 position 属性的值。</td>
</tr>
</tbody>
</table>
<p>csrf：跨站请求伪造防护(在connect中间件看到的)<br>跨站请求伪造（CSRF）利用站点对浏览器的信任漏洞进行攻击。经过你的程序认证的用户访问攻击者创建或攻陷的站点时，这种站点会在用户不知情的情况下代表用户向你的程序发起请求，从而实施攻击。<br>这是一种复杂的攻击，所以我们来举例说明。假定在你的程序中，请求DELETE /account会导致用户的账号被销毁（尽管只有已登录用户可以发起请求）。而用户此时又恰好访问了一个不能防护CSRF的论坛。攻击者可以提交一段脚本发起DELETE /account 请求，销毁用户的账号。对于你的程序来说，这是很糟糕的状况，csrf()中间件可以帮你防护这样的攻击。csrf()会生成一个包含24个字符的唯一ID，认证令牌，作为req.session._csrf附到用户的会话上。然后这个令牌会作为隐藏的输入控件_csrf出现在表单中，CSRF在提交时会验证这个令牌。这个过程每次交互都会执行。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js继承]]></title>
      <url>http://yoursite.com/2016/10/31/js-4/</url>
      <content type="html"><![CDATA[<h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>突然想起来写继承是因为前天看到一个面试题</p>
<blockquote>
<p>写个Animal类，有个Cat类继承它，要求新建一个Cat的实例，可以调用catch方法输出自己的名字”大白的猫”</p>
</blockquote>
<p>当时我写的是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Animal.prototype = &#123;</div><div class="line">	<span class="attr">name</span>:<span class="string">""</span>,</div><div class="line">	<span class="attr">catch</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> Cat = <span class="keyword">new</span> Animal();</div><div class="line">Cat.name = <span class="string">"大白的猫"</span>;</div><div class="line">Cat.catch();</div></pre></td></tr></table></figure></p>
<p>后来回想一下这并不是继承，我只是构造了一个Animal原型对象的新实例，看了一下书，我把代码改成了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.catch = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	Animal.call(<span class="keyword">this</span>, <span class="string">"我是一只大花猫"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat().catch();</div></pre></td></tr></table></figure></p>
<p>这样才算是继承，属于借用构造函数的继承。有点汗颜，所以今天来总结js继承的方式，标准是ECMA5。<br><a id="more"></a></p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>ECMAScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原<br>型让<strong>一个引用类型继承另一个引用类型的属性和方法。</strong><br>简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。</p>
<h4 id="构造函数、原型、实例"><a href="#构造函数、原型、实例" class="headerlink" title="构造函数、原型、实例"></a>构造函数、原型、实例</h4><p>原型：prototype，每个函数都有一个prototype属性，值为对象,当对这个函数的prototype属性不做设置的时候为undefined<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//原型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">prop</span>(<span class="params"></span>)</span>&#123;&#125;;  <span class="comment">//  声明一个prop函数;</span></div><div class="line"></div><div class="line">prop.prototype;  <span class="comment">// undefined;</span></div><div class="line"></div><div class="line"><span class="keyword">typeof</span> prop.prototype;  <span class="comment">//object;</span></div></pre></td></tr></table></figure></p>
<p>构造函数：通过New关键字创建一个新的实例,此时它就是构造函数,也就会重新创建一个作用域。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//当成构造函数调用</span></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"lily"</span>);</div><div class="line">person1.sayName();</div></pre></td></tr></table></figure></p>
<p>实例，需要注意的是指针指向原型而非构造函数。<em>其实还没有弄得很懂，写代码的时候体会一下</em><br>从动态添加原型的例子可以看出来：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line">	<span class="attr">name</span> : <span class="string">"Nicholas"</span>,</div><div class="line">	<span class="attr">age</span> : <span class="number">29</span>,</div><div class="line">	<span class="attr">job</span> : <span class="string">"Software Engineer"</span>,</div><div class="line">	<span class="attr">sayName</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</div><div class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="string">"hi"</span>);</div><div class="line">&#125;;</div><div class="line">friend.sayHi(); <span class="comment">//"hi"（没有问题！）</span></div></pre></td></tr></table></figure></p>
<p>重写整个原型，即用对象字面量方法创建原型方法，会导致重写整个原型。<br>添加方法失效<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</div><div class="line">Person.prototype = &#123;</div><div class="line">	<span class="attr">constructor</span>: Person,</div><div class="line">	<span class="attr">name</span> : <span class="string">"Nicholas"</span>,</div><div class="line">	<span class="attr">age</span> : <span class="number">29</span>,</div><div class="line">	<span class="attr">job</span> : <span class="string">"Software Engineer"</span>,</div><div class="line">	<span class="attr">sayName</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">friend.sayName(); <span class="comment">//error</span></div></pre></td></tr></table></figure></p>
<p>调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系，所以方法添加失败。实例中的指针仅指向原型，而不指向构造函数，实例与原型之间的连接只不过是一个指针，而非一个副本。</p>
<h4 id="实现原型链的基本模式"><a href="#实现原型链的基本模式" class="headerlink" title="实现原型链的基本模式"></a>实现原型链的基本模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SuperType的实例属性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.property = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//SuperType的原型方法</span></div><div class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//SubType的实例属性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//继承了SuperType,子原型等于父实例</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance.getSuperValue()); <span class="comment">//true</span></div><div class="line">alert(instance.getSubValue());  <span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>题外话，这一原型链还少一环，因为每个引用类型的原型都是Object的实例。</p>
<h4 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h4><ol>
<li>使用instanceof 操作符</li>
</ol>
<p>alert(instance instanceof Object); //true<br>alert(instance instanceof SuperType); //true<br>alert(instance instanceof SubType); //true</p>
<ol>
<li>是使用isPrototypeOf()方法</li>
</ol>
<p>alert(Object.prototype.isPrototypeOf(instance)); //true<br>alert(SuperType.prototype.isPrototypeOf(instance)); //true<br>alert(SubType.prototype.isPrototypeOf(instance)); //true</p>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>原型链拥有一个很大的弊端：引用类型值（array之类）的原型会被所有实例共享，因为通过原型实现继承的时候，原型会变成另一个类型的实例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="comment">//继承了SuperType</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(SubType.prototype));<span class="comment">//["colors"]</span></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance2.colors); <span class="comment">//"red,blue,green,black"</span></div></pre></td></tr></table></figure></p>
<p>原型链第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。<br>所以一般使用<strong>借用构造函数</strong>进行继承，在子类型构造函数的内部调用超类型构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="comment">//继承了SuperType</span></div><div class="line">	SuperType.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></div></pre></td></tr></table></figure></p>
<p>通过使用call()方法（或apply()方法也可以），我们实际上是在（未来将要）新创建的SubType 实例的环境下调用了SuperType 构造函数。<br>这样一来，就会在新SubType 对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType 的每个实例就都会具有自己的colors 属性的副本了。</p>
<h4 id="借用构造函数的问题"><a href="#借用构造函数的问题" class="headerlink" title="借用构造函数的问题"></a>借用构造函数的问题</h4><p>如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性，意思就是<strong>构造函数里写属性，原型对象里写方法。</strong><br>下面来看一个例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</div><div class="line">	<span class="comment">//继承属性</span></div><div class="line">	SuperType.call(<span class="keyword">this</span>, name);</div><div class="line">	<span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"><span class="comment">//继承方法</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line">SubType.prototype.constructor = SubType;</div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></div><div class="line">instance1.sayName(); <span class="comment">//"Nicholas";</span></div><div class="line">instance1.sayAge(); <span class="comment">//29</span></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);</div><div class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></div><div class="line">instance2.sayName(); <span class="comment">//"Greg";</span></div><div class="line">instance2.sayAge(); <span class="comment">//27</span></div></pre></td></tr></table></figure></p>
<p>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JavaScript中最常用的继<br>承模式。</p>
<h3 id="更多继承方式，暂且不管"><a href="#更多继承方式，暂且不管" class="headerlink" title="更多继承方式，暂且不管"></a>更多继承方式，暂且不管</h3><ol>
<li>原型式继承</li>
<li>寄生式继承</li>
<li>寄生组合式继承（由于组合继承需要调用两次构造函数，所以寄生组合式继承最优。）</li>
</ol>
<h3 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h3><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>JavaScript 主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。<br>原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[http相关]]></title>
      <url>http://yoursite.com/2016/10/30/work-5/</url>
      <content type="html"><![CDATA[<ul>
<li>网络体系结构</li>
</ul>
<table>
<thead>
<tr>
<th>OSI</th>
<th>TCP/IP</th>
<th>设备</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层、表示层、会话层</td>
<td>应用层（TELNET/FTP/SMTP）</td>
<td>网关</td>
</tr>
<tr>
<td>运输层</td>
<td>运输层（TCP/UDP）</td>
<td>网关</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层（IP/ARP/RARP/ICMP（差错控制/询问））</td>
<td>路由器</td>
</tr>
<tr>
<td>数据链路层(ARP/RARP)、物理层</td>
<td>网络接口层</td>
<td>网桥</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<ul>
<li><p>IPv4：32位，IPv6：128位</p>
</li>
<li><p>TCP和UDP的区别</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td>面向连接</td>
<td>无连接</td>
</tr>
<tr>
<td>可靠</td>
<td>不可靠</td>
</tr>
<tr>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>面向字节流</td>
<td>面向数据报</td>
</tr>
<tr>
<td>一对一</td>
<td>无限制</td>
</tr>
<tr>
<td>SMTP、TELNET（远程终端协议）、HTTP、FTP</td>
<td>DNS之类</td>
</tr>
</tbody>
</table>
<ul>
<li>常用端口号</li>
</ul>
<p>应用程序|FTP|TELNET|DNS|HTTP<br>端口号|21|23|53|80</p>
<ul>
<li>输入一个URL之后，发生了什么事情</li>
</ul>
<ol>
<li>DNS查找。浏览器缓存–&gt;系统缓存–&gt;路由器缓存–&gt;ISP DNS缓存–&gt;DNS服务器一系列的操作</li>
<li>浏览器给服务器发送一个HTTP请求</li>
<li>服务器返回永久重定向响应</li>
<li>浏览器跟踪重定向地址，再次发送请求</li>
<li>服务器处理请求，请求处理阅读请求及它的参数和cookies。它会读取也可能更新一些数据，并讲数据存储在服务器上。然后，需求处理会生成一个HTML响应并发回。</li>
<li>浏览器显示HTML，发送获取嵌入在HTML中的对象</li>
<li>浏览器发送AJAX请求</li>
<li>附<a href="http://fex.baidu.com/blog/2014/05/what-happen/" target="_blank" rel="external">百度FEX</a></li>
<li>临走发现一个<a href="https://github.com/skyline75489/what-happens-when-zh_CN/blob/master/README.rst" target="_blank" rel="external">github</a></li>
</ol>
<ul>
<li>常见的HTTP报头（在百度随便搜了一个东西）</li>
</ul>
<p><strong>General</strong><br>//请求url<br>Request URL:<a href="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=3817578960,1334478084&amp;fm=58&amp;bpow=400&amp;bpoh=300" target="_blank" rel="external">https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=3817578960,1334478084&amp;fm=58&amp;bpow=400&amp;bpoh=300</a><br>//请求方式<br>Request Method:GET<br>//状态码<br>Status Code:200 OK<br>//远程地址<br>Remote Address:123.138.46.33:443<br><strong>响应头</strong><br>Response Headers<br>//HTTP状态<br>HTTP/1.1 200 OK<br>//服务器<br>Server: bfe/1.0.8.13-sslpool-patch<br>//时间<br>Date: Sun, 30 Oct 2016 12:06:59 GMT<br>//类型<br>Content-Type: image/jpeg<br>//响应实体大小，比如这个图片大小为8K<br>Content-Length: 8682<br>Connection: keep-alive<br>ETag: e1139bc1b225c6b15cf5f557191a3b5d<br>Last-Modified: Thu, 01 Jan 1970 00:00:00 GMT<br>Expires: Sat, 05 Nov 2016 15:13:26 GMT<br>Age: 2098413<br>//缓存控制<br>Cache-Control: max-age=2628000<br>//支持range请求<br>Accept-Ranges:bytes<br><strong>请求头</strong><br>Request Headers<br>//GET URL<br>GET /6ONWsjip0QIZ8tyhnq/it/u=3817578960,1334478084&amp;fm=58&amp;bpow=400&amp;bpoh=300 HTTP/1.1<br>//发出请求的页面所在的域<br>Host: ss0.baidu.com<br>//连接方式<br>Connection: keep-alive<br>//浏览器用户代理字符串<br>User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36<br>//客户端接收的内容<br>Accept: image/webp,image/*,*/*;q=0.8<br>//重定向<br>Referer: <a href="https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv\_bp=0&amp;rsv\_idx=1&amp;tn=baidu&amp;wd=13&amp;rsv\_pq=abb5ee1400056681&amp;rsv\_t=14aeOKfIZAsgYDBJrtjMbN3S9J4OR7Qp3t%2FlNCyjfqRxD25VH0wN%2FGIOF8w&amp;rqlang=cn&amp;rsv\_enter=0&amp;rsv\_sug3=3&amp;rsv\_sug1=1&amp;rsv\_sug7=100&amp;inputT=42311&amp;rsv_sug4=42312" target="_blank" rel="external">https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv\_bp=0&amp;rsv\_idx=1&amp;tn=baidu&amp;wd=13&amp;rsv\_pq=abb5ee1400056681&amp;rsv\_t=14aeOKfIZAsgYDBJrtjMbN3S9J4OR7Qp3t%2FlNCyjfqRxD25VH0wN%2FGIOF8w&amp;rqlang=cn&amp;rsv\_enter=0&amp;rsv\_sug3=3&amp;rsv\_sug1=1&amp;rsv\_sug7=100&amp;inputT=42311&amp;rsv_sug4=42312</a><br>//编码<br>Accept-Encoding: gzip, deflate, sdch, br<br>//语言<br>Accept-Language: zh-CN,zh;q=0.8<br>//Cookie<br>Cookie: BAIDUID=9F5B7C3C7D2E52A2B3A65EFD8B03C636:FG=1; PSTM=1477206449; BIDUPSID=70907222E1DDE291452052388B6D9D0F; pgv_pvi=7821050880; PSINO=2; H_PS_PSSID=1456_18241_21083_21455_21406_21394_21377_21190_20718</p>
<p>总结一下，HTTP报头包括general、request、response部分。</p>
<ul>
<li>general：URL、METHOD、状态码、地址</li>
<li>request：GET URL、HOST、浏览器代理、指定接收内容（类型、编码、语言等）、重定向、Cookie</li>
<li><p>response：HTTP状态、服务器、时间、类型、响应实体大小</p>
</li>
<li><p>cookie，localstorage，sessionstorage，session，indexDB</p>
</li>
</ul>
<p>会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。<a href="http://blog.csdn.net/fangaoxin/article/details/6952954/" target="_blank" rel="external">一篇CSDN博客，讲的很清楚</a><br>indexDB：HTML5的本地存储，用作离线应用<br>localstorage：HTML5的本地存储，页面刷新后不消失，方法有setItem、getItem和removeItem，其他的还有点key之类的。</p>
<p>发现还是不熟，明天再总结一下JS事件捕获、冒泡什么的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[10/30零碎问题]]></title>
      <url>http://yoursite.com/2016/10/30/work-4/</url>
      <content type="html"><![CDATA[<h3 id="js内置排序问题"><a href="#js内置排序问题" class="headerlink" title="js内置排序问题"></a>js内置排序问题</h3><ul>
<li>sort接受一个函数为参数，这个函数作为比较的依据。</li>
<li>javascript的sort方法是使用了优化过的快速排序算法来实现的。以V8引擎为例，具体的优化手段有：小数组（小于10项）采用插入排序提升效率，一般数组采用三数取中获得基准元素。</li>
<li>超过2000项的大数组采用更复杂的规则获得基准元素（这条和上面一条降低算法进入最差情况的几率，特别是对于已排序的数组意义很大）。</li>
<li>分区时会分成小于基准、等于基准、大于基准三个分区（解决数组元素相同时快速排序算法效率极差的问题）。</li>
<li>对于小于基准和大于基准这两个分区，选择项数少的进行递归，项数多的进行循环，有效降低递归深度。</li>
<li><a href="http://www.zhouhua.info/2015/06/18/quicksort/" target="_blank" rel="external">深入了解javascript的sort方法</a></li>
<li><a href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js" target="_blank" rel="external">v8源码</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[续10/27]]></title>
      <url>http://yoursite.com/2016/10/29/work-3/</url>
      <content type="html"><![CDATA[<h3 id="续上篇"><a href="#续上篇" class="headerlink" title="续上篇"></a>续上篇</h3><ul>
<li>输入两个链表，找到他们的第一个公共节点。（说实话回来查的时候才知道什么意思。。）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public <span class="keyword">static</span> Node FindFirstCommonNode(Node head1, Node head2)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 得到两个链表的长度</span></div><div class="line">        int length1 = GetListLength(head1);</div><div class="line">        int length2 = GetListLength(head2);</div><div class="line">        int diff = length1 - length2;</div><div class="line"></div><div class="line">        Node headLong = head1;</div><div class="line">        Node headShort = head2;</div><div class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            headLong = head2;</div><div class="line">            headShort = head1;</div><div class="line">            diff = length2 - length1;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 先在长链表上走几步</span></div><div class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; diff; i++)</div><div class="line">        &#123;</div><div class="line">            headLong = headLong.nextNode;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 再同时在两个链表上遍历</span></div><div class="line">        <span class="keyword">while</span> (headLong != <span class="literal">null</span> &amp;&amp; headShort != <span class="literal">null</span> &amp;&amp; headLong != headShort)</div><div class="line">        &#123;</div><div class="line">            headLong = headLong.nextNode;</div><div class="line">            headShort = headShort.nextNode;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Node commonNode = headLong;</div><div class="line">        <span class="keyword">return</span> commonNode;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private <span class="keyword">static</span> int GetListLength(Node head)</div><div class="line">    &#123;</div><div class="line">        int length = <span class="number">0</span>;</div><div class="line">        Node tempNode = head;</div><div class="line">        <span class="keyword">while</span> (tempNode != <span class="literal">null</span>)</div><div class="line">        &#123;</div><div class="line">            tempNode = tempNode.nextNode;</div><div class="line">            length++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> length;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li><p>设计并实现一个LRU，我还是贴个<a href="http://blog.csdn.net/lisonglisonglisong/article/details/45599445" target="_blank" rel="external">博客</a>吧。</p>
</li>
<li><p>和最大子数列</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">s=[<span class="number">1</span>,<span class="number">-2</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">-4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">-5</span>];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> max = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; a.length - <span class="number">1</span>;i++)&#123;</div><div class="line">		<span class="keyword">var</span> temp = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; a.length - i - <span class="number">1</span>; j++) &#123;</div><div class="line">			temp += a[i+j];</div><div class="line">			max = temp &gt; max?temp:max;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> max;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(fun(s)); <span class="comment">//18</span></div></pre></td></tr></table></figure>
<ul>
<li>alt和title的区别</li>
</ul>
<table>
<thead>
<tr>
<th>alt</th>
<th>title</th>
</tr>
</thead>
<tbody>
<tr>
<td>标签的属性</td>
<td>既是标签也是属性</td>
</tr>
<tr>
<td>用来指定替换文字，只能用在img、area和input元素中，用于网页中图片无法正常显示时给用户提供文字说明使其了解图像信息。注意，alt是替代图像作用而不是提供额外说明文字的，另外有助于SEO优化。</td>
<td>用来为元素提供额外说明信息。例如，给超链接标签a添加了title属性，把鼠标移动到该链接上面是，就会显示title的内容，以达到补充说明或者提示的效果。</td>
</tr>
</tbody>
</table>
<ul>
<li>洗牌算法，定义：给你一个1到n的序列，让你随机打乱，保证每个数出现在任意一个位置的概率相同，也就是说在n!个的排列中，每一个排列出现的概率相同。即从一个数组里选出一个数放到新数组，如果这个数被选过，就随机再选一个数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//优化过的算法，时间复杂度为O(n)，空间复杂度为O(0)，即不需要额外空间。</span></div><div class="line"><span class="keyword">void</span> MySwap(int &amp;x, int &amp;y)  </div><div class="line">&#123;  </div><div class="line">    int temp = x;  </div><div class="line">    x = y;  </div><div class="line">    y = temp;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">void</span> Shuffle(int n)  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">for</span>(int i=n<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i--)  </div><div class="line">    &#123;  </div><div class="line">        MySwap(num[i], num[rand()%(i+<span class="number">1</span>)]);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="近期计划"><a href="#近期计划" class="headerlink" title="近期计划"></a>近期计划</h3><p>通过这几天的刷面经跑笔试，发现一些需要总结的东西。</p>
<ol>
<li>http相关</li>
<li>正则表达式</li>
<li>链表相关</li>
<li>什么什么攻防、什么什么跨域</li>
<li>html、css细节，刷几个面经吧</li>
<li>常见的浏览器兼容问题，不知道为什么2016年了还要考这些真的烦</li>
<li>经典算法，这个只能靠做题了，每个看到的题都写一遍。</li>
</ol>
<p>要做的事情</p>
<ol>
<li>完成个人demo页（拖了好久了。。）</li>
<li>vuejs入门</li>
<li>express入门</li>
<li>个人介绍小网页（有生之年估计排不上了。。）</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[10/27笔试总结]]></title>
      <url>http://yoursite.com/2016/10/28/work-2/</url>
      <content type="html"><![CDATA[<h3 id="某音乐公共试题"><a href="#某音乐公共试题" class="headerlink" title="某音乐公共试题"></a>某音乐公共试题</h3><p>不小心发多了一份给我。。。</p>
<ul>
<li>C++中什么时候用const？</li>
</ul>
<p>C++ const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。如果在编程中确实有某个值保持不变，就应该明确使用const，这样可以获得编译器的帮助，提高代码强壮性。<br><a id="more"></a></p>
<ul>
<li>与C中的const有什么区别？</li>
</ul>
<table>
<thead>
<tr>
<th>C</th>
<th>C++</th>
</tr>
</thead>
<tbody>
<tr>
<td>修饰变量，函数参数，返回值等。</td>
<td>C++应用场景丰富得多，可以修饰类，修饰成员变量</td>
</tr>
<tr>
<td>一个不能被改变的普通<strong>变量</strong></td>
<td>常量</td>
</tr>
</tbody>
</table>
<ul>
<li>什么时候使用引用？</li>
</ul>
<p>当必须指向一个对象并且不想改变其指向时，或者在重载操作符并为防止不必要的语义误解时，你应该使用引用；而在除此之外的其他情况下，则应使用指针。</p>
<ul>
<li>引用和指针的区别？</li>
</ul>
<table>
<thead>
<tr>
<th>引用</th>
<th>指针</th>
</tr>
</thead>
<tbody>
<tr>
<td>引用是某块内存的别名</td>
<td>引用是某块内存的别名</td>
</tr>
<tr>
<td>别名</td>
<td>实体</td>
</tr>
<tr>
<td>定义时初始化一次，不可变</td>
<td>可变</td>
</tr>
<tr>
<td>无const</td>
<td>有const</td>
</tr>
<tr>
<td>不能为空</td>
<td>可以为空</td>
</tr>
<tr>
<td>sizeof得到变量大小</td>
<td><a href="http://blog.csdn.net/kangroger/article/details/20653255" target="_blank" rel="external">指针大小</a></td>
</tr>
<tr>
<td>分配内存</td>
<td>不分配</td>
</tr>
</tbody>
</table>
<ul>
<li>模板编程对程序编译期、执行期的影响有哪些？</li>
</ul>
<p>模板是更智能的宏。模板和宏都是编译前代码生成，像宏一样，模板代码会被编译器在编译的第一阶段（在内部转，这点儿与预编译器不同）就展开成合法的C++代码，然后根据展开的代码生成目标代码，链接到最终的应用程序之中。模板与宏相比，它站在更高的抽象层上面，宏操作的是字符串中的token，然而模板却能够操作C++中的类型。所以模板更加安全（因为有类型检查），更加智能（可以根据上下文自动特化）……（<a href="https://www.zhihu.com/question/21656266/answer/18906432" target="_blank" rel="external">摘自知乎</a>），我理解为编译期展开代码，执行期无影响。</p>
<ul>
<li>全局变量和局部变量的区别，怎么实现，操作系统和编译器怎么知道？</li>
</ul>
<p>全局变量和局部变量的区别是在存储器中位置不同，具体说，全局变量存储在全局数据段中，局部变量都有可能，一般来说在堆栈段。</p>
<ul>
<li>读写、互斥锁的实现研究及性能分析</li>
</ul>
<p>读写锁特点：</p>
<ol>
<li>多个读者可以同时进行读</li>
<li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li>
<li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li>
</ol>
<p>互斥锁特点：<br>一次只能一个线程拥有互斥锁，其他线程只有等待</p>
<ul>
<li>Java创建线程有几种不同的方式？倾向哪一种？为什么？</li>
</ul>
<ol>
<li>需要从Java.lang.Thread类派生一个新的线程类，重载它的run()方法； </li>
<li>实现Runnalbe接口，重载Runnalbe接口中的run()方法。</li>
</ol>
<p>在Java中，类仅支持单继承，也就是说，当定义一个新的类的时候，它只能扩展一个外部类.这样，如果创建自定义线程类的时候是通过扩展 Thread类的方法来实现的，那么这个自定义类就不能再去扩展其他的类，也就无法实现更加复杂的功能。因此，如果自定义类必须扩展其他的类，那么就可以使用实现Runnable接口的方法来定义该类为线程类，这样就可以避免Java单继承所带来的局限性。</p>
<p>还有一点最重要的就是使用实现Runnable接口的方式创建的线程可以处理同一资源，从而实现资源的共享。</p>
<ul>
<li>在Java中，能够改变main()方法的返回类型？能否声明main()方法为非静态？</li>
</ul>
<p>不能。不能。如果main()允许是非静态的，那么在调用main方法时，JVM就得实例化它的类。在实例化时，还得调用类的构造函数。如果这个类的构造函数有参数，那么届时就会出现歧义。<br><a href="http://www.codeceo.com/article/10-java-main-interview.html" target="_blank" rel="external">10个Java main方法的面试题</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//例如，在下面的程序中，在实例化类“A”的时候，JVM传递什么参数？</span></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">&#123;</div><div class="line">	public MainMethod(int i)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">//Constructor taking one argument</span></div><div class="line">	&#125;</div><div class="line"> 	public <span class="keyword">void</span> main(<span class="built_in">String</span>[] args)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">//main method as non-static</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>实现libc中的函数strstr</li>
</ul>
<p>比较简单，找出第二次出现的字符<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">strstr</span>(<span class="params">Array,key</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">Array</span>.indexOf(key,<span class="built_in">Array</span>.indexOf(key)+<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line">s = <span class="string">"sdfad"</span>;</div><div class="line">alert(strstr(s,<span class="string">"d"</span>)); <span class="comment">//4</span></div></pre></td></tr></table></figure></p>
<ul>
<li>字符串循环右移N位</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//string不能直接进行赋值操作，首先转换为数组</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">str,num</span>)</span>&#123;</div><div class="line">	str = str.split(<span class="string">''</span>);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; num;i++)&#123;</div><div class="line">		<span class="keyword">var</span> j = str.length - <span class="number">1</span>;</div><div class="line">		<span class="keyword">var</span> temp = str[j];</div><div class="line">		<span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</div><div class="line">			str[j] = str[--j];</div><div class="line">		&#125;</div><div class="line">		str[<span class="number">0</span>] = temp;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> str.join(<span class="string">''</span>);</div><div class="line">&#125;</div><div class="line">alert(fun(<span class="string">"123456"</span>,<span class="number">2</span>));</div><div class="line"></div><div class="line"><span class="comment">//字符串逆置实现，C</span></div><div class="line"><span class="comment">/*实现循环移位 </span></div><div class="line">   比如：123456，循环右移2位，实际上是将字符串分成两部分 </div><div class="line">     先对1234逆置，得到4321 </div><div class="line">     再对56逆置，得到65 </div><div class="line">     此时字符串是432165 </div><div class="line">     最后再对整个字符串432165逆置，得到561234。实现了循环移位 </div><div class="line">     时间复杂度在线性时间内。 </div><div class="line">*/  </div><div class="line"></div><div class="line"><span class="keyword">void</span> invert(char ch[],int m,int n)  </div><div class="line">&#123;  </div><div class="line">    int i;  </div><div class="line">    char temp;  </div><div class="line">    <span class="keyword">for</span>(i=m;i&lt;(m+n)/<span class="number">2</span>;i++)  </div><div class="line">    &#123;  </div><div class="line">        temp=ch[i];  </div><div class="line">        ch[i]=ch[m+n<span class="number">-1</span>-i];  </div><div class="line">        ch[m+n<span class="number">-1</span>-i]=temp;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">void</span> loopMove(char c[],int steps)  </div><div class="line">&#123;  </div><div class="line">    int len;  </div><div class="line">    len=strlen(c)-steps;  </div><div class="line">    invert(c,<span class="number">0</span>,len);<span class="comment">//对字符串中前len位进行逆置  </span></div><div class="line">    invert(c,len,strlen(c));<span class="comment">//对字符串后steps位进行逆置  </span></div><div class="line">    invert(c,<span class="number">0</span>,strlen(c));<span class="comment">//再对整个字符串进行逆置  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>将所有单词首字母转为大写</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//w3cschool....还要抽一天专门看正则才行....</span></div><div class="line">name = <span class="string">'aaa bbb ccc'</span>;</div><div class="line">uw = name.replace(<span class="regexp">/\b\w+\b/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">word</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> word.substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase()+word.substring(<span class="number">1</span>);&#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>今天陪雨晨逛了半天有点累，就先写到这。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[闭包]]></title>
      <url>http://yoursite.com/2016/10/25/js-3/</url>
      <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</div><div class="line">	<span class="comment">//匿名函数可以访问propertyName</span></div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> value1 = object1[propertyName];</div><div class="line">		<span class="keyword">var</span> value2 = object2[propertyName];</div><div class="line">		<span class="keyword">if</span> (value1 &lt; value2)&#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">		&#125; </div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125; </div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line">&lt;!--more--&gt;</div></pre></td></tr></table></figure>
<h3 id="彻底理解闭包—-作用域链"><a href="#彻底理解闭包—-作用域链" class="headerlink" title="彻底理解闭包—-作用域链"></a>彻底理解闭包—-作用域链</h3><ul>
<li>当某个函数被调用时，会创建一个执行环境（execution context）及相应的作用域链。</li>
<li>然后，使用arguments 和其他命名参数的值来初始化函数的活动对象（activation object）。</li>
<li>但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境。</li>
<li>在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。</li>
</ul>
<p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>)</span>&#123;</div><div class="line">	<span class="keyword">if</span> (value1 &lt; value2)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125; </div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> result = compare(<span class="number">5</span>, <span class="number">10</span>);</div></pre></td></tr></table></figure></p>
<ul>
<li>以上代码先定义了compare()函数，然后又在全局作用域中调用了它。当调用compare()时，会<br>创建一个包含arguments、value1 和value2 的活动对象。</li>
<li>全局执行环境的变量对象（包含result和compare）在compare()执行环境的作用域链中则处于第二位。</li>
<li>后台的每个执行环境都有一个表示变量的对象—变量对象。全局环境的变量对象始终存在，而像<br>compare()函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建compare()函数<br>时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。</li>
<li>当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。</li>
<li>此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端。</li>
<li>对于这个例子中compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。</li>
</ul>
<p>啰嗦一大堆的结论：<strong>作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。</strong>无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。</p>
<h3 id="回到闭包"><a href="#回到闭包" class="headerlink" title="回到闭包"></a>回到闭包</h3><p>我还是直接贴一些闭包吧，讲起来有点费劲。简单的说就是内部函数在定义他的作用域的外部被引用，就创建了该内部函数的闭包。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello2</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> text = <span class="string">'Hello '</span> + name; <span class="comment">// Local variable</span></div><div class="line">    <span class="keyword">var</span> say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(text); &#125;</div><div class="line">    <span class="keyword">return</span> say;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> say2 = sayHello2(<span class="string">'Bob'</span>);</div><div class="line">say2(); <span class="comment">// logs "Hello Bob"</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">say667</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// Local variable that ends up within closure</span></div><div class="line">    <span class="keyword">var</span> num = <span class="number">42</span>;</div><div class="line">    <span class="keyword">var</span> say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(num); &#125;</div><div class="line">    num++;</div><div class="line">    <span class="keyword">return</span> say;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sayNumber = say667();</div><div class="line">sayNumber(); <span class="comment">// logs 43</span></div></pre></td></tr></table></figure>
<h3 id="作用域链副作用"><a href="#作用域链副作用" class="headerlink" title="作用域链副作用"></a>作用域链副作用</h3><p>作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。<strong>别忘了闭包所保存的是整个变量对象，而不是某个特殊的变量</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">	<span class="comment">//实际操作匿名函数会被解析成字符串不知道为什么</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">		result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> i;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>修改方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">		result[i] = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> i;</div><div class="line">		&#125;)(i); <span class="comment">//保存变量</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>优点：共享函数作用域, 便于开放一些接口或变量供外部使用;</li>
<li>注意事项: 由于闭包可能会使得函数中变量被长期保存在内存中, 从而大量消耗内存, 影响页面性能, 因此不能滥用, 并且在IE浏览中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li>
</ul>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>总结的很烂，理解还不是很透彻，贴个<a href="http://louiszhai.github.io/2015/12/22/scopeChain/" target="_blank" rel="external">博客链接</a>，还有<a href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work" target="_blank" rel="external">stackoverflow</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[飞鱼笔试以及零散总结]]></title>
      <url>http://yoursite.com/2016/10/20/work-1/</url>
      <content type="html"><![CDATA[<h3 id="位操作实现abs"><a href="#位操作实现abs" class="headerlink" title="位操作实现abs"></a>位操作实现abs</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">-120</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> num*(<span class="number">1</span>-((num&gt;&gt;&gt;<span class="number">31</span>)&lt;&lt;<span class="number">1</span>));</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(abs(num));<span class="comment">//120</span></div></pre></td></tr></table></figure>
<h3 id="递归实现数组求和"><a href="#递归实现数组求和" class="headerlink" title="递归实现数组求和"></a>递归实现数组求和</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,n</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> (n === <span class="number">0</span>)?<span class="number">0</span>:sum(a,n - <span class="number">1</span>) + a[n - <span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="一个未解决的"><a href="#一个未解决的" class="headerlink" title="一个未解决的"></a>一个未解决的</h3><p>#define six 2*3 和#define six 2 * 3有没有区别？<br>暂时想不到</p>
<h3 id="js加载"><a href="#js加载" class="headerlink" title="js加载"></a>js加载</h3><ul>
<li><p>同步加载 又称阻塞模式，会阻止浏览器的后续处理，停止了后续的解析，因此停止了后续的文件加载（如图像）、渲染、代码执行。<br>js 之所以要同步执行，是因为 js 中可能有输出 document内容、修改dom、重定向等行为，所以默认同步执行才是安全的。<br>以前的一般建议是把script放在页面末尾body之前，这样尽可能减少这种阻塞行为，而先让页面展示出来。<br>简单说：加载的网络 timeline 是瀑布模型，而异步加载的 timeline 是并发模型。</p>
</li>
<li><p>异步加载 它允许无阻塞资源加载，并且使 onload 启动更快，允许页面内容加载，而不需要刷新页面，也可以根据页面内容延迟加载依赖。</p>
</li>
</ul>
<ol>
<li><p>动态创建</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">     <span class="keyword">var</span> s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);  </div><div class="line">     s.type = <span class="string">'text/javascript'</span>;  </div><div class="line">     s.async = <span class="literal">true</span>;  </div><div class="line">     s.src = <span class="string">'http://yourdomain.com/script.js'</span>;  </div><div class="line">     <span class="keyword">var</span> x = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'script'</span>)[<span class="number">0</span>];  </div><div class="line">     x.parentNode.insertBefore(s, x);  </div><div class="line"> &#125;)();</div></pre></td></tr></table></figure>
</li>
<li><p>html5 async属性</p>
</li>
<li>onload加载，与第一种类似</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js引用类型--Function]]></title>
      <url>http://yoursite.com/2016/10/19/js-2/</url>
      <content type="html"><![CDATA[<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><blockquote>
<p>今天总结js引用类型Function，标准依然是ECMA5。</p>
</blockquote>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>,<span class="string">"num2"</span>,<span class="string">"return num1 + num2"</span>);</div><div class="line"><span class="comment">//最后一个参数始终被看成是函数体</span></div><div class="line"><span class="comment">//不推荐，会两次解析代码。</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>函数名其实仅仅为指向函数的指针：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherSum = sum;</div><div class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></div><div class="line"></div><div class="line">sum = <span class="literal">null</span>;</div><div class="line">alert(anotherSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></div></pre></td></tr></table></figure></p>
<h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>由于函数名仅仅为指向函数的指针，所以很好理解为什么js没有重载的概念。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> num + <span class="number">100</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> num + <span class="number">200</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = addSomeNumber(<span class="number">100</span>); <span class="comment">//300</span></div></pre></td></tr></table></figure></p>
<h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><p>解析器在向执行环境中加载数据的时候，会先读取函数声明，并使其在执行任何代码之前可用（function declaration hoisting,函数声明提升），至于函数表达式，则必须等到解析器执行到它所在的代码行才会真正被解释执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;   <span class="comment">//正确</span></div><div class="line"></div><div class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));</div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;   <span class="comment">//unexpected identifier，函数表达式被解析器执行到代码行才执行，所以声明未提前。</span></div></pre></td></tr></table></figure></p>
<h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><p>函数名本身就是变量，所以函数可以作为值使用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction,someArgument</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> someFunction(someArgument);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add10</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> num + <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = callSomeFunction(add10,<span class="number">10</span>);  <span class="comment">//20</span></div><div class="line"><span class="comment">//add10未带()，所以访问的是函数指针而不会执行函数。</span></div></pre></td></tr></table></figure></p>
<p>从函数中返回另一个函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>)</span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1,object2</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> value1 = object1[propertyName];</div><div class="line">		<span class="keyword">var</span> value2 = object2[propertyName];</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> value1 - value2; <span class="comment">//升序</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> data = [&#123;<span class="attr">name</span>: <span class="string">"Zachary"</span>,<span class="attr">age</span>: <span class="number">28</span>&#125;,&#123;<span class="attr">name</span>: <span class="string">"Nicholas"</span>,<span class="attr">age</span>: <span class="number">29</span>&#125;];</div><div class="line"></div><div class="line">data.sort(createComparisonFunction(<span class="string">"name"</span>));</div><div class="line">alert(data[<span class="number">0</span>].name); <span class="comment">//Nicholas</span></div><div class="line"></div><div class="line">data.sort(createComparisonFunction(<span class="string">"age"</span>));</div><div class="line">alert(data[<span class="number">0</span>].name); <span class="comment">//Zachary</span></div></pre></td></tr></table></figure></p>
<h3 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h3><ul>
<li>caller 保存着调用当前函数的函数的引用，如果在全局作用域中调用当前函数，它的值为NULL</li>
<li>this 引用的是函数据以执行的执行环境</li>
<li>arguments 一个类数组对象，包含传入函数中的所有参数，这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用callee可以消除耦合</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">	<span class="keyword">if</span>(num &lt;= <span class="number">1</span>)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">		<span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> trueFactorial = fatorial;</div><div class="line">fatorial = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">alert(trueFactorial(<span class="number">5</span>)); <span class="comment">//120，如果不使用callee就会返回0，解耦必要性</span></div><div class="line">alert(fatorial(<span class="number">5</span>)); <span class="comment">//0</span></div></pre></td></tr></table></figure>
<h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3><ul>
<li>length 参数个数</li>
<li>prototype ECMA而言，所有的方法都保存在prototype名下，prototype不可枚举，无法用for-in方法发现。关于prototype，复习到了再总结，先挖个坑。</li>
<li>每个函数都包含两个非继承而来的方法：apply()和call()，这两个方法相当于this对象的值，用途是在特定作用域中调用函数。apply()和call()的区别仅仅在于参数：</li>
</ul>
<table>
<thead>
<tr>
<th>apply()</th>
<th>call()</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用作用域，参数数组(可以为Array实例，也可以为arguments对象)</td>
<td>调用作用域，参数必须逐个列举</td>
</tr>
</tbody>
</table>
<p>这两个方法最重要的用法是<strong>扩充作用域</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">color</span>:<span class="string">"blue"</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line">sayColor(); <span class="comment">//red</span></div><div class="line"></div><div class="line">sayColor.call(<span class="keyword">this</span>); <span class="comment">//red</span></div><div class="line">sayColor.call(<span class="built_in">window</span>); <span class="comment">//red</span></div><div class="line">sayColor.call(o); <span class="comment">//blue</span></div></pre></td></tr></table></figure></p>
<ul>
<li>最后一个方法，bind()，这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">color</span>:<span class="string">"blue"</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> objectSayColor = sayColor.bind(o); <span class="comment">//blue，即使在全局调用objectSayColor，值也为blue</span></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js引用类型--Array]]></title>
      <url>http://yoursite.com/2016/10/18/js-1/</url>
      <content type="html"><![CDATA[<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><blockquote>
<p>今天上课总结的js引用类型Array，标准是ECMA5，至于为什么，因为我看的书就是讲ECMA5的啊。</p>
</blockquote>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>一维数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//new可以省略</span></div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">           = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);   <span class="comment">//长度为20</span></div><div class="line">           = <span class="keyword">new</span> <span class="built_in">Array</span>([<span class="number">20</span>]);  <span class="comment">//含一项，第一项为20</span></div><div class="line">           = [<span class="string">"red"</span>,<span class="string">"green"</span>];</div><div class="line">           = [<span class="number">1</span>,<span class="number">2</span>,];        <span class="comment">//不推荐，IE为三项，第三项为undefined</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>多维数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先创建一个一维数组，然后该一维数组的所有成员再创建一维数据</span></div><div class="line"><span class="keyword">var</span> persons = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"></div><div class="line">persons[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">persons[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">persons[<span class="number">2</span>] = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"></div><div class="line">persons[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">"zhangsan"</span>;</div><div class="line">persons[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">25</span>;</div><div class="line">persons[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">"lisi"</span>;</div><div class="line">persons[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">22</span>;</div><div class="line">persons[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">"wangwu"</span>;</div><div class="line">persons[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">32</span>;</div><div class="line">persons[<span class="number">0</span>] = [<span class="string">"zhangsan"</span>, <span class="number">25</span>];</div><div class="line">persons[<span class="number">1</span>] = [<span class="string">"lisi"</span>, <span class="number">21</span>];</div><div class="line">persons[<span class="number">2</span>] = [<span class="string">"wangwu"</span>, <span class="number">32</span>];</div><div class="line"></div><div class="line"><span class="comment">//length值为一维数组长度</span></div><div class="line"></div><div class="line"><span class="comment">//第二种写法</span></div><div class="line"><span class="keyword">var</span> persons = [[<span class="string">"zhangsan"</span>, <span class="number">25</span>], [<span class="string">"lisi"</span>, <span class="number">21</span>], [<span class="string">"wangwu"</span>, <span class="number">32</span>]];</div></pre></td></tr></table></figure></p>
<p>*利用length可以在末尾添加新项，length值为最后索引值加1，中间空值会被定义为undefined</p>
<h3 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h3><ul>
<li>Array.isArray()   //建议使用</li>
<li>value instanceof Array   //可能因为页面有框架产生作用域问题</li>
</ul>
<h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</div><div class="line">alert(colors.toString());  <span class="comment">//red,blue,green 字符串</span></div><div class="line">alert(colors.valueOf());   <span class="comment">//red,blue,green 返回的是数组</span></div><div class="line">alert(colors);             <span class="comment">//red,blue,green 数组 **书上写字符串**</span></div><div class="line"><span class="comment">//还有一个toLocaleString()方法，调用每一项的toLocaleString()方法</span></div><div class="line"><span class="comment">//验证的话，重写每个Array的toLocaleString()、toString()方法就可以看出来了</span></div><div class="line">alert(colors.join(<span class="string">","</span>));   <span class="comment">//red,blue,green 如果某项为空则为空字符串</span></div></pre></td></tr></table></figure>
<h3 id="栈、队列方法"><a href="#栈、队列方法" class="headerlink" title="栈、队列方法"></a>栈、队列方法</h3><ul>
<li>pop()</li>
<li>push()</li>
<li>shift()</li>
<li>unshift()</li>
</ul>
<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><ul>
<li>reverse()</li>
<li>sort()</li>
</ul>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><ul>
<li>slice()</li>
<li>splice()</li>
<li>concat()，基于当前数组中的所有项创建一个新数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"green"</span>];</div><div class="line"><span class="keyword">var</span> colors2 = colors.concat(<span class="string">"yellow"</span>,[<span class="string">"black"</span>,<span class="string">"brown"</span>]);</div><div class="line"><span class="comment">//red,green,blue,yellow,black,brown 空则为复制</span></div></pre></td></tr></table></figure>
<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><ul>
<li>indexOf()</li>
<li>lastIndexOf() //正逆序查找，严格相等，传参key，起始位置</li>
</ul>
<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><table>
<thead>
<tr>
<th>函数</th>
<th>every()</th>
<th>filter()</th>
<th>forEach()</th>
<th>map()</th>
<th>some()</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值</td>
<td>bool</td>
<td>true结果Array</td>
<td>无</td>
<td>操作结果Array</td>
<td>bool</td>
</tr>
</tbody>
</table>
<h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//reduce(),reduceRight() 迭代数组所有项</span></div><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev,cur,index,array</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> prev + cur;</div><div class="line">&#125;);</div><div class="line">alert(sum);<span class="comment">//15</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多余部分省略为点点点]]></title>
      <url>http://yoursite.com/2016/10/17/css-1/</url>
      <content type="html"><![CDATA[<h2 id="多余部分省略解决方案"><a href="#多余部分省略解决方案" class="headerlink" title="多余部分省略解决方案"></a>多余部分省略解决方案</h2><p>今天笔试勤智数码遇到的问题，没有答出来，回来总结一下。</p>
<h3 id="单行"><a href="#单行" class="headerlink" title="单行"></a>单行</h3><p>CSS就能实现，挺简单的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.test&#123;</div><div class="line">		<span class="attr">width</span>: <span class="number">50</span>px;</div><div class="line">		overflow: hidden;</div><div class="line">		text-overflow: ellipsis;</div><div class="line">		white-space: nowrap;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="WebKit浏览器或移动端的页面"><a href="#WebKit浏览器或移动端的页面" class="headerlink" title="WebKit浏览器或移动端的页面"></a>WebKit浏览器或移动端的页面</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.test&#123;</div><div class="line">		<span class="attr">overflow</span> : hidden;</div><div class="line">		text-overflow: ellipsis;</div><div class="line">		display: -webkit-box;</div><div class="line">		-webkit-line-clamp: <span class="number">2</span>;</div><div class="line">		-webkit-box-orient: vertical;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="跨浏览器兼容方案"><a href="#跨浏览器兼容方案" class="headerlink" title="跨浏览器兼容方案"></a>跨浏览器兼容方案</h3><p>比较靠谱简单的做法就是设置相对定位的容器高度，用包含省略号(…)的元素模拟实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">p &#123;</div><div class="line">    <span class="attr">position</span>:relative;</div><div class="line">    line-height:<span class="number">1.4</span>em;</div><div class="line">    <span class="comment">/* 3 times the line-height to show 3 lines */</span></div><div class="line">    height:<span class="number">4.2</span>em;</div><div class="line">    overflow:hidden;</div><div class="line">&#125;</div><div class="line">p::after &#123;</div><div class="line">    <span class="attr">content</span>:<span class="string">"..."</span>;</div><div class="line">    font-weight:bold;</div><div class="line">    position:absolute;</div><div class="line">    bottom:<span class="number">0</span>;</div><div class="line">    right:<span class="number">0</span>;</div><div class="line">    padding:<span class="number">0</span> <span class="number">20</span>px <span class="number">1</span>px <span class="number">45</span>px;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="黑科技"><a href="#黑科技" class="headerlink" title="黑科技"></a>黑科技</h3><p>插件<a href="http://dotdotdot.frebsite.nl" target="_blank" rel="external">jQuery.dotdotdot</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	$(<span class="string">"#wrapper"</span>).dotdotdot(&#123;</div><div class="line">		<span class="comment">//	configuration goes here</span></div><div class="line">	&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>转自<a href="http://blog.csdn.net/fanhu6816/article/details/52063758" target="_blank" rel="external">博客</a>，有更为详细的总结</p>
<h2 id="明天要做的事情"><a href="#明天要做的事情" class="headerlink" title="明天要做的事情"></a>明天要做的事情</h2><ul>
<li>信息安全小测</li>
<li>研究Express框架</li>
<li>总结SEO、分页相关知识</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一些排序算法]]></title>
      <url>http://yoursite.com/2016/10/13/algorithm-sort/</url>
      <content type="html"><![CDATA[<h2 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>算法思想：对n个元素的序列进行n-1趟的排序。第一趟排序对序列进行从头到尾的扫描，找到最小的元素与第一个元素交换，第二趟排序对序列从第二个元素起到序列尾扫描，找到最小元素与第二个元素交换，以此类推。<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> SelectionSort(int a[n])&#123;</div><div class="line">	<span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++)&#123;</div><div class="line">		int min = i;</div><div class="line">		<span class="keyword">for</span>(int j = i + <span class="number">1</span>;j &lt; n;j++)</div><div class="line">			<span class="keyword">if</span>(a[min] &gt; a[j]) min = j;</div><div class="line">		swap(a[min],a[i]);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>算法思想：对有n个元素的序列进行n-1趟排序，相邻元素逆序则交换。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> BubbleSort(int a[n])&#123;</div><div class="line">	<span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++)&#123;</div><div class="line">		<span class="comment">//改进算法，如果一趟未逆序则已经有序</span></div><div class="line">		<span class="comment">//bool exchange = true;</span></div><div class="line">		<span class="keyword">for</span>(int j = <span class="number">0</span>;j &lt; n - i - <span class="number">1</span>;j++)&#123;</div><div class="line">			<span class="keyword">if</span>(a[j + <span class="number">1</span>] &lt; a[j])&#123;</div><div class="line">				swap(a[j],a[j + <span class="number">1</span>]);</div><div class="line">				<span class="comment">//exchange = false;</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(exchange)&#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>算法思想：将数据插入已经排好序的有序数据中，本质上属于减治策略。</p>
<blockquote>
<p>关于减治策略：减治技术利用一个问题给定实例的解和同样问题较小的实例的解中的某种关系。一旦建立了这种关系，就可以采取递归手段。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> InsertSort(int a[n])&#123;</div><div class="line">	<span class="comment">//将数列第一个元素减去，当成一个数列</span></div><div class="line">	<span class="keyword">for</span>(int i = <span class="number">1</span>;i &lt; n - <span class="number">1</span>;i++)&#123;</div><div class="line">		v = a[i];</div><div class="line">		int j = i - <span class="number">1</span>;</div><div class="line">		<span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; v)&#123;</div><div class="line">			a[j + <span class="number">1</span>] = a[j];</div><div class="line">			j--;</div><div class="line">		&#125;</div><div class="line">		a[j + <span class="number">1</span>] = v;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//改进插入排序，往前插入时进行二分查找</span></div><div class="line"><span class="comment">//平均性能更快，时间复杂度降至O(NlogN)</span></div><div class="line"><span class="keyword">void</span> InsertBinarySort(int arr[n],int len)&#123;</div><div class="line">	<span class="keyword">for</span>(int i = <span class="number">1</span>;i &lt; len;i++)&#123;</div><div class="line">		<span class="keyword">if</span>(arr[i] &lt; arr[i - <span class="number">1</span>])&#123;</div><div class="line">			int temp = arr[i];</div><div class="line">			int low = <span class="number">0</span>;</div><div class="line">			int high = i - <span class="number">1</span>;</div><div class="line">			<span class="keyword">while</span>(low &lt;= high)&#123;</div><div class="line">				mid = (low + high) / <span class="number">2</span>;</div><div class="line">				<span class="keyword">if</span>(temp &lt; arr[mid])&#123;</div><div class="line">					high = mid - <span class="number">1</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span>&#123;</div><div class="line">					low = mid + <span class="number">1</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">for</span>(int j = i;j &gt; low;j--)&#123;</div><div class="line">				arr[j] = arr[j - <span class="number">1</span>];</div><div class="line">			&#125;</div><div class="line">			arr[low] = temp;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>算法思想：对冒泡排序的改进，一般从第一个元素开始，将比它小的元素放在前面，比它大的元素放在后面。</p>
<p>一趟快排的算法：</p>
<p>1.从数列中挑出一个元素，称为 “基准”（pivot/key）</p>
<p>2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</p>
<p>3.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> sort(int *a, int left, int right)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="comment">/*如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了*/</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line">    int i = left;</div><div class="line">    int j = right;</div><div class="line">    int key = a[left];</div><div class="line">     </div><div class="line">    <span class="keyword">while</span>(i &lt; j)                               <span class="comment">/*控制在当组内寻找一遍*/</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &lt;= a[j])</div><div class="line">        <span class="comment">/*而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升</span></div><div class="line">        序还是降序）2，没有符合条件1的，并且i与j的大小没有反转*/ </div><div class="line">        &#123;</div><div class="line">            j--;<span class="comment">/*向前寻找*/</span></div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        a[i] = a[j];</div><div class="line">        <span class="comment">/*找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是</span></div><div class="line">        a[left]，那么就是给key）*/</div><div class="line">         </div><div class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &gt;= a[i])</div><div class="line">        <span class="comment">/*这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反，</span></div><div class="line">        因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反*/</div><div class="line">        &#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        a[j] = a[i];</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    a[i] = key;<span class="comment">/*当在当组内找完一遍以后就把中间数key回归*/</span></div><div class="line">    sort(a, left, i - <span class="number">1</span>);<span class="comment">/*最后用同样的方式对分出来的左边的小组进行同上的做法*/</span></div><div class="line">    sort(a, i + <span class="number">1</span>, right);<span class="comment">/*用同样的方式对分出来的右边的小组进行同上的做法*/</span></div><div class="line">                       <span class="comment">/*当然最后可能会出现很多分左右，直到每一组的i = j 为止*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="不常用的"><a href="#不常用的" class="headerlink" title="不常用的"></a>不常用的</h2><p>贴个源码以防我以后想看</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> HAdjust(ElemTp R[], int i, int n) <span class="comment">//避免swap</span></div><div class="line">&#123; </div><div class="line">	int temp=R[i]; </div><div class="line">	int key=temp;</div><div class="line">	int j,iL,iR;</div><div class="line">	<span class="keyword">while</span>(i&lt;=n/<span class="number">2</span><span class="number">-1</span>) <span class="comment">//叶子停止，非叶子继续</span></div><div class="line">	&#123; </div><div class="line">		iL=<span class="number">2</span>*i+<span class="number">1</span>; iR=iL+<span class="number">1</span>; <span class="comment">//求R[i]的左/右儿子下标</span></div><div class="line">		j=iL; <span class="comment">//j为R[i]要交换的结点下标</span></div><div class="line">		<span class="keyword">if</span>(iR&lt;n&amp;&amp;iR&gt;iL) j=iR;</div><div class="line">		<span class="keyword">if</span>(key&gt;R[j]) <span class="keyword">break</span>; <span class="comment">//根结点最大则结束调整</span></div><div class="line">		R[i]=R[j]; i=j;</div><div class="line">	&#125;</div><div class="line">	R[i]=temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> HeapSort(ElemTp R[], int n)</div><div class="line">&#123; <span class="comment">//初始建大根堆</span></div><div class="line">	<span class="keyword">for</span>(int i=n/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) </div><div class="line">		HAdjust(R, i, n);</div><div class="line">	<span class="keyword">for</span>(int i=<span class="number">1</span>; i&lt;n; i++)</div><div class="line">	&#123; </div><div class="line">		swap(R[<span class="number">0</span>], R[n-i]);</div><div class="line">		HAdjust(R, <span class="number">0</span>, n-i);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> ShellSort(ElemTp R[], int n, int d[], int m)</div><div class="line"><span class="comment">// R[0..n-1]升序排序, d[0..m-1]为递减的增量</span></div><div class="line">&#123; </div><div class="line">	int j,e,key,t;</div><div class="line">	<span class="keyword">for</span>(int s=<span class="number">0</span>; s&lt;m; s++) <span class="comment">//m趟剩余类分组插入排序</span></div><div class="line">		<span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;d[s]; i++) <span class="comment">//模d[s]余i类插入排序</span></div><div class="line">			<span class="keyword">for</span>(j=i+d[s]; j&lt;n; j+=d[s])</div><div class="line">			&#123; </div><div class="line">				e=R[j]; </div><div class="line">				key=R[j];</div><div class="line">				<span class="keyword">for</span>(t=j-d[s]; t&gt;=i&amp;&amp;R[t]&gt;key; t-=d[s])</div><div class="line">					R[t+d[s]]=R[t];</div><div class="line">                R[t+d[s]]=e;</div><div class="line">			&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> merge(ElemTp p[], int s, int m, int t, ElemTp q[])</div><div class="line"><span class="comment">//p[s..m]已升序; p[m+1..t]已升序(smt)</span></div><div class="line"><span class="comment">//归并p[s..m]和p[m+1..t], 结果存于q[s..t], 使q[s..t]升序</span></div><div class="line">&#123; </div><div class="line">	int i=s; </div><div class="line">	int j=m+<span class="number">1</span>; </div><div class="line">	int k=s;</div><div class="line">	<span class="keyword">while</span>(i&lt;=m&amp;&amp;j&lt;=t)</div><div class="line">		<span class="keyword">if</span>(p[i]&lt;=p[j]) q[k++]=p[i++];</div><div class="line">		<span class="keyword">else</span> q[k++]=p[j++]; <span class="comment">//用&lt;=是稳定的, 用&lt;不稳定</span></div><div class="line">	<span class="keyword">while</span>(i&lt;=m) q[k++]=p[i++];</div><div class="line">	<span class="keyword">while</span>(j&lt;=t) q[k++]=p[j++];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> MergeSort(ElemTp R[], int n)</div><div class="line">&#123; </div><div class="line">	ElemTp *p=R, *A=<span class="keyword">new</span> ElemTp[n], *q=A; int w, s, m, t;</div><div class="line">	<span class="keyword">for</span>(w=<span class="number">1</span>; w&lt;n; w*=<span class="number">2</span>) <span class="comment">//w为每趟分块长度</span></div><div class="line">	&#123; </div><div class="line">		<span class="keyword">for</span>(s=<span class="number">0</span>; s&lt;n; s+=<span class="number">2</span>*w)</div><div class="line">		&#123; </div><div class="line">			m=min(n<span class="number">-1</span>, s+w<span class="number">-1</span>); </div><div class="line">			t=min(n<span class="number">-1</span>, m+w);</div><div class="line">			merge(p, s, m, t, q);</div><div class="line">		&#125;</div><div class="line">		swap(p, q); <span class="comment">//交换使p为归并源, q为归并目标</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(p==A) </div><div class="line">		<span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;n; i++) R[i]=A[i];</div><div class="line">	<span class="keyword">delete</span> []A; <span class="comment">//删除辅助数组A</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h2><p>顺便用下markdown表格</p>
<table>
<thead>
<tr>
<th style="text-align:center">Algorithm</th>
<th style="text-align:center">Average</th>
<th style="text-align:center">Best</th>
<th style="text-align:center">Worst</th>
<th style="text-align:center">extra space</th>
<th style="text-align:center">stable</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">直接插入排序</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">简单选择排序</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">折半插入排序</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(logN)~O(N^2)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
</tbody>
</table>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>写了差不多三分之一的样子，我要去跑步了，我再不跑步可能就要死了，明天再更新下，嗯我也不知道我在自言自语什么东西，但是今天遇到一个宇宙BUG，我要拿框框记下来。  <em>—-10-13</em></p>
<p>手写了四个算法常用算法，感觉面试应该没问题了，贴了几个不常用的排序以防我以后要看，虽然我知道我应该是不会看的。 <em>—-10-15更新</em></p>
<blockquote><p>当遇到百思不得其解的编译错误，试下把tab换成四下空格，对的没错就是这么无解。</p>
<footer><strong>Yucheng Fang</strong><cite>Bug log</cite></footer></blockquote>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://yoursite.com/2016/10/12/hello-world/</url>
      <content type="html"><![CDATA[<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>过去的一两个月一直在各种笔试、面试中疲于奔命，有喜有忧，情绪起伏不定，想做的太多以至于常常四处尝试，然而发现知道的越多不知道的就越多，今天忙了半天时间开启了Hexo的大门，想起先前无来由的膨胀觉得十分幽默。</p>
<a id="more"></a>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>昨天4399的面试经历让我意识到企业需要的应届生是什么样子的，平心而论玩轮子十分简单，语言基础还是要好好打，不要下次突然被问到指针和引用的区别一脸懵逼。</p>
<p>纪念一下猝不及防让写的二分查找，由于脑袋一片空白写了一个递归，回家发现居然写对了，感觉自己还是有一点….天赋？不过也是时候把常用算法搞一遍了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearchRecursion</span><span class="params">(<span class="keyword">int</span> arry[],<span class="keyword">int</span> value,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(low &gt; high)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span>(arry[mid] == value)</div><div class="line">        <span class="keyword">return</span> mid;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value &lt; arry[mid])</div><div class="line">        <span class="keyword">return</span>    BinarySearchRecursion(arry,value,low,mid - <span class="number">1</span>);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span>    BinarySearchRecursion(arry,value,mid + <span class="number">1</span>,high);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>看了一个下午又瞎又饿，刚开始用MD，感觉还行，插件将后续装上。<br>路漫漫其修远兮~</p>
]]></content>
    </entry>
    
  
  
</search>
