<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[续10/27]]></title>
      <url>http://yoursite.com/2016/10/29/work-3/</url>
      <content type="html"><![CDATA[<h3 id="续上篇"><a href="#续上篇" class="headerlink" title="续上篇"></a>续上篇</h3><ul>
<li>输入两个链表，找到他们的第一个公共节点。（说实话回来查的时候才知道什么意思。。）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public <span class="keyword">static</span> Node FindFirstCommonNode(Node head1, Node head2)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 得到两个链表的长度</span></div><div class="line">        int length1 = GetListLength(head1);</div><div class="line">        int length2 = GetListLength(head2);</div><div class="line">        int diff = length1 - length2;</div><div class="line"></div><div class="line">        Node headLong = head1;</div><div class="line">        Node headShort = head2;</div><div class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            headLong = head2;</div><div class="line">            headShort = head1;</div><div class="line">            diff = length2 - length1;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 先在长链表上走几步</span></div><div class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; diff; i++)</div><div class="line">        &#123;</div><div class="line">            headLong = headLong.nextNode;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 再同时在两个链表上遍历</span></div><div class="line">        <span class="keyword">while</span> (headLong != <span class="literal">null</span> &amp;&amp; headShort != <span class="literal">null</span> &amp;&amp; headLong != headShort)</div><div class="line">        &#123;</div><div class="line">            headLong = headLong.nextNode;</div><div class="line">            headShort = headShort.nextNode;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Node commonNode = headLong;</div><div class="line">        <span class="keyword">return</span> commonNode;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private <span class="keyword">static</span> int GetListLength(Node head)</div><div class="line">    &#123;</div><div class="line">        int length = <span class="number">0</span>;</div><div class="line">        Node tempNode = head;</div><div class="line">        <span class="keyword">while</span> (tempNode != <span class="literal">null</span>)</div><div class="line">        &#123;</div><div class="line">            tempNode = tempNode.nextNode;</div><div class="line">            length++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> length;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>设计并实现一个LRU，我还是贴个<a href="http://blog.csdn.net/lisonglisonglisong/article/details/45599445" target="_blank" rel="external">博客</a>吧。</p>
</li>
<li><p>和最大子数列</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">s=[<span class="number">1</span>,<span class="number">-2</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">-4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">-5</span>];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> max = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; a.length - <span class="number">1</span>;i++)&#123;</div><div class="line">		<span class="keyword">var</span> temp = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; a.length - i - <span class="number">1</span>; j++) &#123;</div><div class="line">			temp += a[i+j];</div><div class="line">			max = temp &gt; max?temp:max;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> max;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(fun(s)); <span class="comment">//18</span></div></pre></td></tr></table></figure>
<ul>
<li>alt和title的区别</li>
</ul>
<table>
<thead>
<tr>
<th>alt</th>
<th>title</th>
</tr>
</thead>
<tbody>
<tr>
<td>标签的属性</td>
<td>既是标签也是属性</td>
</tr>
<tr>
<td>用来指定替换文字，只能用在img、area和input元素中，用于网页中图片无法正常显示时给用户提供文字说明使其了解图像信息。注意，alt是替代图像作用而不是提供额外说明文字的，另外有助于SEO优化。</td>
<td>用来为元素提供额外说明信息。例如，给超链接标签a添加了title属性，把鼠标移动到该链接上面是，就会显示title的内容，以达到补充说明或者提示的效果。</td>
</tr>
</tbody>
</table>
<ul>
<li>洗牌算法，定义：给你一个1到n的序列，让你随机打乱，保证每个数出现在任意一个位置的概率相同，也就是说在n!个的排列中，每一个排列出现的概率相同。即从一个数组里选出一个数放到新数组，如果这个数被选过，就随机再选一个数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//优化过的算法，时间复杂度为O(n)，空间复杂度为O(0)，即不需要额外空间。</span></div><div class="line"><span class="keyword">void</span> MySwap(int &amp;x, int &amp;y)  </div><div class="line">&#123;  </div><div class="line">    int temp = x;  </div><div class="line">    x = y;  </div><div class="line">    y = temp;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">void</span> Shuffle(int n)  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">for</span>(int i=n<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i--)  </div><div class="line">    &#123;  </div><div class="line">        MySwap(num[i], num[rand()%(i+<span class="number">1</span>)]);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="近期计划"><a href="#近期计划" class="headerlink" title="近期计划"></a>近期计划</h3><p>通过这几天的刷面经跑笔试，发现一些需要总结的东西。</p>
<ol>
<li>http相关</li>
<li>正则表达式</li>
<li>链表相关</li>
<li>什么什么攻防、什么什么跨域</li>
<li>html、css细节，刷几个面经吧</li>
<li>常见的浏览器兼容问题，不知道为什么2016年了还要考这些真的烦</li>
<li>经典算法，这个只能靠做题了，每个看到的题都写一遍。</li>
</ol>
<p>要做的事情</p>
<ol>
<li>完成个人demo页（拖了好久了。。）</li>
<li>vuejs入门</li>
<li>express入门</li>
<li>个人介绍小网页（有生之年估计排不上了。。）</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[10/27笔试总结]]></title>
      <url>http://yoursite.com/2016/10/28/work-2/</url>
      <content type="html"><![CDATA[<h3 id="某音乐公共试题"><a href="#某音乐公共试题" class="headerlink" title="某音乐公共试题"></a>某音乐公共试题</h3><p>不小心发多了一份给我。。。</p>
<ul>
<li>C++中什么时候用const？</li>
</ul>
<p>C++ const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。如果在编程中确实有某个值保持不变，就应该明确使用const，这样可以获得编译器的帮助，提高代码强壮性。<br><a id="more"></a></p>
<ul>
<li>与C中的const有什么区别？</li>
</ul>
<table>
<thead>
<tr>
<th>C</th>
<th>C++</th>
</tr>
</thead>
<tbody>
<tr>
<td>修饰变量，函数参数，返回值等。</td>
<td>C++应用场景丰富得多，可以修饰类，修饰成员变量</td>
</tr>
<tr>
<td>一个不能被改变的普通<strong>变量</strong></td>
<td>常量</td>
</tr>
</tbody>
</table>
<ul>
<li>什么时候使用引用？</li>
</ul>
<p>当必须指向一个对象并且不想改变其指向时，或者在重载操作符并为防止不必要的语义误解时，你应该使用引用；而在除此之外的其他情况下，则应使用指针。</p>
<ul>
<li>引用和指针的区别？</li>
</ul>
<table>
<thead>
<tr>
<th>引用</th>
<th>指针</th>
</tr>
</thead>
<tbody>
<tr>
<td>引用是某块内存的别名</td>
<td>引用是某块内存的别名</td>
</tr>
<tr>
<td>别名</td>
<td>实体</td>
</tr>
<tr>
<td>定义时初始化一次，不可变</td>
<td>可变</td>
</tr>
<tr>
<td>无const</td>
<td>有const</td>
</tr>
<tr>
<td>不能为空</td>
<td>可以为空</td>
</tr>
<tr>
<td>sizeof得到变量大小</td>
<td><a href="http://blog.csdn.net/kangroger/article/details/20653255" target="_blank" rel="external">指针大小</a></td>
</tr>
<tr>
<td>分配内存</td>
<td>不分配</td>
</tr>
</tbody>
</table>
<ul>
<li>模板编程对程序编译期、执行期的影响有哪些？</li>
</ul>
<p>模板是更智能的宏。模板和宏都是编译前代码生成，像宏一样，模板代码会被编译器在编译的第一阶段（在内部转，这点儿与预编译器不同）就展开成合法的C++代码，然后根据展开的代码生成目标代码，链接到最终的应用程序之中。模板与宏相比，它站在更高的抽象层上面，宏操作的是字符串中的token，然而模板却能够操作C++中的类型。所以模板更加安全（因为有类型检查），更加智能（可以根据上下文自动特化）……（<a href="https://www.zhihu.com/question/21656266/answer/18906432" target="_blank" rel="external">摘自知乎</a>），我理解为编译期展开代码，执行期无影响。</p>
<ul>
<li>全局变量和局部变量的区别，怎么实现，操作系统和编译器怎么知道？</li>
</ul>
<p>全局变量和局部变量的区别是在存储器中位置不同，具体说，全局变量存储在全局数据段中，局部变量都有可能，一般来说在堆栈段。</p>
<ul>
<li>读写、互斥锁的实现研究及性能分析</li>
</ul>
<p>读写锁特点：</p>
<ol>
<li>多个读者可以同时进行读</li>
<li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li>
<li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li>
</ol>
<p>互斥锁特点：<br>一次只能一个线程拥有互斥锁，其他线程只有等待</p>
<ul>
<li>Java创建线程有几种不同的方式？倾向哪一种？为什么？</li>
</ul>
<ol>
<li>需要从Java.lang.Thread类派生一个新的线程类，重载它的run()方法； </li>
<li>实现Runnalbe接口，重载Runnalbe接口中的run()方法。</li>
</ol>
<p>在Java中，类仅支持单继承，也就是说，当定义一个新的类的时候，它只能扩展一个外部类.这样，如果创建自定义线程类的时候是通过扩展 Thread类的方法来实现的，那么这个自定义类就不能再去扩展其他的类，也就无法实现更加复杂的功能。因此，如果自定义类必须扩展其他的类，那么就可以使用实现Runnable接口的方法来定义该类为线程类，这样就可以避免Java单继承所带来的局限性。</p>
<p>还有一点最重要的就是使用实现Runnable接口的方式创建的线程可以处理同一资源，从而实现资源的共享。</p>
<ul>
<li>在Java中，能够改变main()方法的返回类型？能否声明main()方法为非静态？</li>
</ul>
<p>不能。不能。如果main()允许是非静态的，那么在调用main方法时，JVM就得实例化它的类。在实例化时，还得调用类的构造函数。如果这个类的构造函数有参数，那么届时就会出现歧义。<br><a href="http://www.codeceo.com/article/10-java-main-interview.html" target="_blank" rel="external">10个Java main方法的面试题</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//例如，在下面的程序中，在实例化类“A”的时候，JVM传递什么参数？</span></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">&#123;</div><div class="line">	public MainMethod(int i)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">//Constructor taking one argument</span></div><div class="line">	&#125;</div><div class="line"> 	public <span class="keyword">void</span> main(<span class="built_in">String</span>[] args)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">//main method as non-static</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>实现libc中的函数strstr</li>
</ul>
<p>比较简单，找出第二次出现的字符<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">strstr</span>(<span class="params">Array,key</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">Array</span>.indexOf(key,<span class="built_in">Array</span>.indexOf(key)+<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line">s = <span class="string">"sdfad"</span>;</div><div class="line">alert(strstr(s,<span class="string">"d"</span>)); <span class="comment">//4</span></div></pre></td></tr></table></figure></p>
<ul>
<li>字符串循环右移N位</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//string不能直接进行赋值操作，所以遇到还是用C写吧</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">str,num</span>)</span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; num;i++)&#123;</div><div class="line">		<span class="keyword">var</span> j = str.length - <span class="number">1</span>;</div><div class="line">		<span class="keyword">var</span> temp = str[j];</div><div class="line">		<span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</div><div class="line">			str[j] = str[j<span class="number">-1</span>];</div><div class="line">			<span class="built_in">console</span>.log(str);</div><div class="line">			j--;</div><div class="line">		&#125;</div><div class="line">		str[<span class="number">0</span>] = temp;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> str;</div><div class="line">&#125;</div><div class="line">alert(fun(<span class="string">"123456"</span>,<span class="number">2</span>));</div><div class="line"></div><div class="line"><span class="comment">//字符串逆置实现，C</span></div><div class="line"><span class="comment">/*实现循环移位 </span></div><div class="line">   比如：123456，循环右移2位，实际上是将字符串分成两部分 </div><div class="line">     先对1234逆置，得到4321 </div><div class="line">     再对56逆置，得到65 </div><div class="line">     此时字符串是432165 </div><div class="line">     最后再对整个字符串432165逆置，得到561234。实现了循环移位 </div><div class="line">     时间复杂度在线性时间内。 </div><div class="line">*/  </div><div class="line"></div><div class="line"><span class="keyword">void</span> invert(char ch[],int m,int n)  </div><div class="line">&#123;  </div><div class="line">    int i;  </div><div class="line">    char temp;  </div><div class="line">    <span class="keyword">for</span>(i=m;i&lt;(m+n)/<span class="number">2</span>;i++)  </div><div class="line">    &#123;  </div><div class="line">        temp=ch[i];  </div><div class="line">        ch[i]=ch[m+n<span class="number">-1</span>-i];  </div><div class="line">        ch[m+n<span class="number">-1</span>-i]=temp;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">void</span> loopMove(char c[],int steps)  </div><div class="line">&#123;  </div><div class="line">    int len;  </div><div class="line">    len=strlen(c)-steps;  </div><div class="line">    invert(c,<span class="number">0</span>,len);<span class="comment">//对字符串中前len位进行逆置  </span></div><div class="line">    invert(c,len,strlen(c));<span class="comment">//对字符串后steps位进行逆置  </span></div><div class="line">    invert(c,<span class="number">0</span>,strlen(c));<span class="comment">//再对整个字符串进行逆置  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>将所有单词首字母转为大写</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//w3cschool....还要抽一天专门看正则才行....</span></div><div class="line">name = <span class="string">'aaa bbb ccc'</span>;</div><div class="line">uw = name.replace(<span class="regexp">/\b\w+\b/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">word</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> word.substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase()+word.substring(<span class="number">1</span>);&#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>今天陪雨晨逛了半天有点累，就先写到这。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[闭包]]></title>
      <url>http://yoursite.com/2016/10/25/js-3/</url>
      <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</div><div class="line">	<span class="comment">//匿名函数可以访问propertyName</span></div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> value1 = object1[propertyName];</div><div class="line">		<span class="keyword">var</span> value2 = object2[propertyName];</div><div class="line">		<span class="keyword">if</span> (value1 &lt; value2)&#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">		&#125; </div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125; </div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line">&lt;!--more--&gt;</div></pre></td></tr></table></figure>
<h3 id="彻底理解闭包—-作用域链"><a href="#彻底理解闭包—-作用域链" class="headerlink" title="彻底理解闭包—-作用域链"></a>彻底理解闭包—-作用域链</h3><ul>
<li>当某个函数被调用时，会创建一个执行环境（execution context）及相应的作用域链。</li>
<li>然后，使用arguments 和其他命名参数的值来初始化函数的活动对象（activation object）。</li>
<li>但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境。</li>
<li>在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。</li>
</ul>
<p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>)</span>&#123;</div><div class="line">	<span class="keyword">if</span> (value1 &lt; value2)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125; </div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> result = compare(<span class="number">5</span>, <span class="number">10</span>);</div></pre></td></tr></table></figure></p>
<ul>
<li>以上代码先定义了compare()函数，然后又在全局作用域中调用了它。当调用compare()时，会<br>创建一个包含arguments、value1 和value2 的活动对象。</li>
<li>全局执行环境的变量对象（包含result和compare）在compare()执行环境的作用域链中则处于第二位。</li>
<li>后台的每个执行环境都有一个表示变量的对象—变量对象。全局环境的变量对象始终存在，而像<br>compare()函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建compare()函数<br>时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。</li>
<li>当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。</li>
<li>此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端。</li>
<li>对于这个例子中compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。</li>
</ul>
<p>啰嗦一大堆的结论：<strong>作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。</strong>无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。</p>
<h3 id="回到闭包"><a href="#回到闭包" class="headerlink" title="回到闭包"></a>回到闭包</h3><p>我还是直接贴一些闭包吧，讲起来有点费劲。简单的说就是内部函数在定义他的作用域的外部被引用，就创建了该内部函数的闭包。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello2</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> text = <span class="string">'Hello '</span> + name; <span class="comment">// Local variable</span></div><div class="line">    <span class="keyword">var</span> say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(text); &#125;</div><div class="line">    <span class="keyword">return</span> say;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> say2 = sayHello2(<span class="string">'Bob'</span>);</div><div class="line">say2(); <span class="comment">// logs "Hello Bob"</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">say667</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// Local variable that ends up within closure</span></div><div class="line">    <span class="keyword">var</span> num = <span class="number">42</span>;</div><div class="line">    <span class="keyword">var</span> say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(num); &#125;</div><div class="line">    num++;</div><div class="line">    <span class="keyword">return</span> say;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sayNumber = say667();</div><div class="line">sayNumber(); <span class="comment">// logs 43</span></div></pre></td></tr></table></figure>
<h3 id="作用域链副作用"><a href="#作用域链副作用" class="headerlink" title="作用域链副作用"></a>作用域链副作用</h3><p>作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。<strong>别忘了闭包所保存的是整个变量对象，而不是某个特殊的变量</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">	<span class="comment">//实际操作匿名函数会被解析成字符串不知道为什么</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">		result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> i;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>修改方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">		result[i] = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> i;</div><div class="line">		&#125;)(i); <span class="comment">//保存变量</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>优点：共享函数作用域, 便于开放一些接口或变量供外部使用;</li>
<li>注意事项: 由于闭包可能会使得函数中变量被长期保存在内存中, 从而大量消耗内存, 影响页面性能, 因此不能滥用, 并且在IE浏览中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li>
</ul>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>总结的很烂，理解还不是很透彻，贴个<a href="http://louiszhai.github.io/2015/12/22/scopeChain/" target="_blank" rel="external">博客链接</a>，还有<a href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work" target="_blank" rel="external">stackoverflow</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[飞鱼笔试以及零散总结]]></title>
      <url>http://yoursite.com/2016/10/20/work-1/</url>
      <content type="html"><![CDATA[<h3 id="位操作实现abs"><a href="#位操作实现abs" class="headerlink" title="位操作实现abs"></a>位操作实现abs</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">-120</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> num*(<span class="number">1</span>-((num&gt;&gt;&gt;<span class="number">31</span>)&lt;&lt;<span class="number">1</span>));</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(abs(num));<span class="comment">//120</span></div></pre></td></tr></table></figure>
<h3 id="递归实现数组求和"><a href="#递归实现数组求和" class="headerlink" title="递归实现数组求和"></a>递归实现数组求和</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,n</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> (n===<span class="number">0</span>)?<span class="number">0</span>:sum(a[n<span class="number">-1</span>],n<span class="number">-1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="一个未解决的"><a href="#一个未解决的" class="headerlink" title="一个未解决的"></a>一个未解决的</h3><p>#define six 2*3 和#define six 2 * 3有没有区别？<br>暂时想不到</p>
<h3 id="js加载"><a href="#js加载" class="headerlink" title="js加载"></a>js加载</h3><ul>
<li><p>同步加载 又称阻塞模式，会阻止浏览器的后续处理，停止了后续的解析，因此停止了后续的文件加载（如图像）、渲染、代码执行。<br>js 之所以要同步执行，是因为 js 中可能有输出 document内容、修改dom、重定向等行为，所以默认同步执行才是安全的。<br>以前的一般建议是把script放在页面末尾body之前，这样尽可能减少这种阻塞行为，而先让页面展示出来。<br>简单说：加载的网络 timeline 是瀑布模型，而异步加载的 timeline 是并发模型。</p>
</li>
<li><p>异步加载 它允许无阻塞资源加载，并且使 onload 启动更快，允许页面内容加载，而不需要刷新页面，也可以根据页面内容延迟加载依赖。</p>
</li>
</ul>
<ol>
<li><p>动态创建</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">     <span class="keyword">var</span> s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);  </div><div class="line">     s.type = <span class="string">'text/javascript'</span>;  </div><div class="line">     s.async = <span class="literal">true</span>;  </div><div class="line">     s.src = <span class="string">'http://yourdomain.com/script.js'</span>;  </div><div class="line">     <span class="keyword">var</span> x = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'script'</span>)[<span class="number">0</span>];  </div><div class="line">     x.parentNode.insertBefore(s, x);  </div><div class="line"> &#125;)();</div></pre></td></tr></table></figure>
</li>
<li><p>html5 async属性</p>
</li>
<li>onload加载，与第一种类似</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js引用类型--Function]]></title>
      <url>http://yoursite.com/2016/10/19/js-2/</url>
      <content type="html"><![CDATA[<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><blockquote>
<p>今天总结js引用类型Function，标准依然是ECMA5。</p>
</blockquote>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>,<span class="string">"num2"</span>,<span class="string">"return num1 + num2"</span>);</div><div class="line"><span class="comment">//最后一个参数始终被看成是函数体</span></div><div class="line"><span class="comment">//不推荐，会两次解析代码。</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>函数名其实仅仅为指向函数的指针：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherSum = sum;</div><div class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></div><div class="line"></div><div class="line">sum = <span class="literal">null</span>;</div><div class="line">alert(anotherSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></div></pre></td></tr></table></figure></p>
<h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>由于函数名仅仅为指向函数的指针，所以很好理解为什么js没有重载的概念。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> num + <span class="number">100</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> num + <span class="number">200</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = addSomeNumber(<span class="number">100</span>); <span class="comment">//300</span></div></pre></td></tr></table></figure></p>
<h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><p>解析器在向执行环境中加载数据的时候，会先读取函数声明，并使其在执行任何代码之前可用（function declaration hoisting,函数声明提升），至于函数表达式，则必须等到解析器执行到它所在的代码行才会真正被解释执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;   <span class="comment">//正确</span></div><div class="line"></div><div class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));</div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;   <span class="comment">//unexpected identifier，函数表达式被解析器执行到代码行才执行，所以声明未提前。</span></div></pre></td></tr></table></figure></p>
<h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><p>函数名本身就是变量，所以函数可以作为值使用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction,someArgument</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> someFunction(someArgument);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add10</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> num + <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = callSomeFunction(add10,<span class="number">10</span>);  <span class="comment">//20</span></div><div class="line"><span class="comment">//add10未带()，所以访问的是函数指针而不会执行函数。</span></div></pre></td></tr></table></figure></p>
<p>从函数中返回另一个函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>)</span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1,object2</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> value1 = object1[propertyName];</div><div class="line">		<span class="keyword">var</span> value2 = object2[propertyName];</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> value1 - value2; <span class="comment">//升序</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> data = [&#123;<span class="attr">name</span>: <span class="string">"Zachary"</span>,<span class="attr">age</span>: <span class="number">28</span>&#125;,&#123;<span class="attr">name</span>: <span class="string">"Nicholas"</span>,<span class="attr">age</span>: <span class="number">29</span>&#125;];</div><div class="line"></div><div class="line">data.sort(createComparisonFunction(<span class="string">"name"</span>));</div><div class="line">alert(data[<span class="number">0</span>].name); <span class="comment">//Nicholas</span></div><div class="line"></div><div class="line">data.sort(createComparisonFunction(<span class="string">"age"</span>));</div><div class="line">alert(data[<span class="number">0</span>].name); <span class="comment">//Zachary</span></div></pre></td></tr></table></figure></p>
<h3 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h3><ul>
<li>caller 保存着调用当前函数的函数的引用，如果在全局作用域中调用当前函数，它的值为NULL</li>
<li>this 引用的是函数据以执行的执行环境</li>
<li>arguments 一个类数组对象，包含传入函数中的所有参数，这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用callee可以消除耦合</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">	<span class="keyword">if</span>(num &lt;= <span class="number">1</span>)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">		<span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> trueFactorial = fatorial;</div><div class="line">fatorial = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">alert(trueFactorial(<span class="number">5</span>)); <span class="comment">//120，如果不使用callee就会返回0，解耦必要性</span></div><div class="line">alert(fatorial(<span class="number">5</span>)); <span class="comment">//0</span></div></pre></td></tr></table></figure>
<h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3><ul>
<li>length 参数个数</li>
<li>prototype ECMA而言，所有的方法都保存在prototype名下，prototype不可枚举，无法用for-in方法发现。关于prototype，复习到了再总结，先挖个坑。</li>
<li>每个函数都包含两个非继承而来的方法：apply()和call()，这两个方法相当于this对象的值，用途是在特定作用域中调用函数。apply()和call()的区别仅仅在于参数：</li>
</ul>
<table>
<thead>
<tr>
<th>apply()</th>
<th>call()</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用作用域，参数数组(可以为Array实例，也可以为arguments对象)</td>
<td>调用作用域，参数必须逐个列举</td>
</tr>
</tbody>
</table>
<p>这两个方法最重要的用法是<strong>扩充作用域</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">color</span>:<span class="string">"blue"</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line">sayColor(); <span class="comment">//red</span></div><div class="line"></div><div class="line">sayColor.call(<span class="keyword">this</span>); <span class="comment">//red</span></div><div class="line">sayColor.call(<span class="built_in">window</span>); <span class="comment">//red</span></div><div class="line">sayColor.call(o); <span class="comment">//blue</span></div></pre></td></tr></table></figure></p>
<ul>
<li>最后一个方法，bind()，这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">color</span>:<span class="string">"blue"</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> objectSayColor = sayColor.bind(o); <span class="comment">//blue，即使在全局调用objectSayColor，值也为blue</span></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js引用类型--Array]]></title>
      <url>http://yoursite.com/2016/10/18/js-1/</url>
      <content type="html"><![CDATA[<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><blockquote>
<p>今天上课总结的js引用类型Array，标准是ECMA5，至于为什么，因为我看的书就是讲ECMA5的啊。</p>
</blockquote>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>一维数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//new可以省略</span></div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">           = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);   <span class="comment">//长度为20</span></div><div class="line">           = <span class="keyword">new</span> <span class="built_in">Array</span>([<span class="number">20</span>]);  <span class="comment">//含一项，第一项为20</span></div><div class="line">           = [<span class="string">"red"</span>,<span class="string">"green"</span>];</div><div class="line">           = [<span class="number">1</span>,<span class="number">2</span>,];        <span class="comment">//不推荐，IE为三项，第三项为undefined</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>多维数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先创建一个一维数组，然后该一维数组的所有成员再创建一维数据</span></div><div class="line"><span class="keyword">var</span> persons = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"></div><div class="line">persons[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">persons[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">persons[<span class="number">2</span>] = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"></div><div class="line">persons[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">"zhangsan"</span>;</div><div class="line">persons[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">25</span>;</div><div class="line">persons[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">"lisi"</span>;</div><div class="line">persons[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">22</span>;</div><div class="line">persons[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">"wangwu"</span>;</div><div class="line">persons[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">32</span>;</div><div class="line">persons[<span class="number">0</span>] = [<span class="string">"zhangsan"</span>, <span class="number">25</span>];</div><div class="line">persons[<span class="number">1</span>] = [<span class="string">"lisi"</span>, <span class="number">21</span>];</div><div class="line">persons[<span class="number">2</span>] = [<span class="string">"wangwu"</span>, <span class="number">32</span>];</div><div class="line"></div><div class="line"><span class="comment">//length值为一维数组长度</span></div><div class="line"></div><div class="line"><span class="comment">//第二种写法</span></div><div class="line"><span class="keyword">var</span> persons = [[<span class="string">"zhangsan"</span>, <span class="number">25</span>], [<span class="string">"lisi"</span>, <span class="number">21</span>], [<span class="string">"wangwu"</span>, <span class="number">32</span>]];</div></pre></td></tr></table></figure></p>
<p>*利用length可以在末尾添加新项，length值为最后索引值加1，中间空值会被定义为undefined</p>
<h3 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h3><ul>
<li>Array.isArray()   //建议使用</li>
<li>value instanceof Array   //可能因为页面有框架产生作用域问题</li>
</ul>
<h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</div><div class="line">alert(colors.toString());  <span class="comment">//red,blue,green 字符串</span></div><div class="line">alert(colors.valueOf());   <span class="comment">//red,blue,green 返回的是数组</span></div><div class="line">alert(colors);             <span class="comment">//red,blue,green 字符串，隐式调用toString()</span></div><div class="line"><span class="comment">//还有一个toLocaleString()方法，调用每一项的toLocaleString()方法</span></div><div class="line"><span class="comment">//验证的话，重写每个Array的toLocaleString()、toString()方法就可以看出来了</span></div><div class="line">alert(colors.join(<span class="string">","</span>));   <span class="comment">//red,blue,green 如果某项为空则为空字符串</span></div></pre></td></tr></table></figure>
<h3 id="栈、队列方法"><a href="#栈、队列方法" class="headerlink" title="栈、队列方法"></a>栈、队列方法</h3><ul>
<li>pop()</li>
<li>push()</li>
<li>shift()</li>
<li>unshift()</li>
</ul>
<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><ul>
<li>reverse()</li>
<li>sort()</li>
</ul>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><ul>
<li>slice()</li>
<li>splice()</li>
<li>concat()，基于当前数组中的所有项创建一个新数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"green"</span>];</div><div class="line"><span class="keyword">var</span> colors2 = colors.concat(<span class="string">"yellow"</span>,[<span class="string">"black"</span>,<span class="string">"brown"</span>]);</div><div class="line"><span class="comment">//red,green,blue,yellow,black,brown 空则为复制</span></div></pre></td></tr></table></figure>
<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><ul>
<li>indexOf()</li>
<li>lastIndexOf() //正逆序查找，严格相等，传参key，起始位置</li>
</ul>
<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><table>
<thead>
<tr>
<th>函数</th>
<th>every()</th>
<th>filter()</th>
<th>forEach()</th>
<th>map()</th>
<th>some()</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值</td>
<td>bool</td>
<td>true结果Array</td>
<td>无</td>
<td>操作结果Array</td>
<td>bool</td>
</tr>
</tbody>
</table>
<h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//reduce(),reduceRight() 迭代数组所有项</span></div><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev,cur,index,array</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> prev + cur;</div><div class="line">&#125;);</div><div class="line">alert(sum);<span class="comment">//15</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多余部分省略为点点点]]></title>
      <url>http://yoursite.com/2016/10/17/css-1/</url>
      <content type="html"><![CDATA[<h2 id="多余部分省略解决方案"><a href="#多余部分省略解决方案" class="headerlink" title="多余部分省略解决方案"></a>多余部分省略解决方案</h2><p>今天笔试勤智数码遇到的问题，没有答出来，回来总结一下。</p>
<h3 id="单行"><a href="#单行" class="headerlink" title="单行"></a>单行</h3><p>CSS就能实现，挺简单的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.test&#123;</div><div class="line">		<span class="attr">width</span>: <span class="number">50</span>px;</div><div class="line">		overflow: hidden;</div><div class="line">		text-overflow: ellipsis;</div><div class="line">		white-space: nowrap;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="WebKit浏览器或移动端的页面"><a href="#WebKit浏览器或移动端的页面" class="headerlink" title="WebKit浏览器或移动端的页面"></a>WebKit浏览器或移动端的页面</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.test&#123;</div><div class="line">		<span class="attr">overflow</span> : hidden;</div><div class="line">		text-overflow: ellipsis;</div><div class="line">		display: -webkit-box;</div><div class="line">		-webkit-line-clamp: <span class="number">2</span>;</div><div class="line">		-webkit-box-orient: vertical;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="跨浏览器兼容方案"><a href="#跨浏览器兼容方案" class="headerlink" title="跨浏览器兼容方案"></a>跨浏览器兼容方案</h3><p>比较靠谱简单的做法就是设置相对定位的容器高度，用包含省略号(…)的元素模拟实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">p &#123;</div><div class="line">    <span class="attr">position</span>:relative;</div><div class="line">    line-height:<span class="number">1.4</span>em;</div><div class="line">    <span class="comment">/* 3 times the line-height to show 3 lines */</span></div><div class="line">    height:<span class="number">4.2</span>em;</div><div class="line">    overflow:hidden;</div><div class="line">&#125;</div><div class="line">p::after &#123;</div><div class="line">    <span class="attr">content</span>:<span class="string">"..."</span>;</div><div class="line">    font-weight:bold;</div><div class="line">    position:absolute;</div><div class="line">    bottom:<span class="number">0</span>;</div><div class="line">    right:<span class="number">0</span>;</div><div class="line">    padding:<span class="number">0</span> <span class="number">20</span>px <span class="number">1</span>px <span class="number">45</span>px;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="黑科技"><a href="#黑科技" class="headerlink" title="黑科技"></a>黑科技</h3><p>插件<a href="http://dotdotdot.frebsite.nl" target="_blank" rel="external">jQuery.dotdotdot</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	$(<span class="string">"#wrapper"</span>).dotdotdot(&#123;</div><div class="line">		<span class="comment">//	configuration goes here</span></div><div class="line">	&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>转自<a href="http://blog.csdn.net/fanhu6816/article/details/52063758" target="_blank" rel="external">博客</a>，有更为详细的总结</p>
<h2 id="明天要做的事情"><a href="#明天要做的事情" class="headerlink" title="明天要做的事情"></a>明天要做的事情</h2><ul>
<li>信息安全小测</li>
<li>研究Express框架</li>
<li>总结SEO、分页相关知识</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一些排序算法]]></title>
      <url>http://yoursite.com/2016/10/13/algorithm-sort/</url>
      <content type="html"><![CDATA[<h2 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>算法思想：对n个元素的序列进行n-1趟的排序。第一趟排序对序列进行从头到尾的扫描，找到最小的元素与第一个元素交换，第二趟排序对序列从第二个元素起到序列尾扫描，找到最小元素与第二个元素交换，以此类推。<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> SelectionSort(int a[n])&#123;</div><div class="line">	<span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++)&#123;</div><div class="line">		int min = i;</div><div class="line">		<span class="keyword">for</span>(int j = i + <span class="number">1</span>;j &lt; n - <span class="number">1</span>;j++)</div><div class="line">			<span class="keyword">if</span>(a[min] &gt; a[j]) min = j;</div><div class="line">		swap(a[min],a[i]);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>算法思想：对有n个元素的序列进行n-1趟排序，相邻元素逆序则交换。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> BubbleSort(int a[n])&#123;</div><div class="line">	<span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)&#123;</div><div class="line">		<span class="comment">//改进算法，如果一趟未逆序则已经有序</span></div><div class="line">		<span class="comment">//bool exchange = true;</span></div><div class="line">		<span class="keyword">for</span>(int j = <span class="number">0</span>;j &lt; n-i<span class="number">-1</span>;j++)&#123;</div><div class="line">			<span class="keyword">if</span>(a[j + <span class="number">1</span>] &lt; a[j])&#123;</div><div class="line">				swap(a[j],a[j + <span class="number">1</span>]);</div><div class="line">				<span class="comment">//exchange = false;</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(exchange)&#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>算法思想：将数据插入已经排好序的有序数据中，本质上属于减治策略。</p>
<blockquote>
<p>关于减治策略：减治技术利用一个问题给定实例的解和同样问题较小的实例的解中的某种关系。一旦建立了这种关系，就可以采取递归手段。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> InsertSort(int a[n])&#123;</div><div class="line">	<span class="comment">//将数列第一个元素减去，当成一个数列</span></div><div class="line">	<span class="keyword">for</span>(int i = <span class="number">1</span>;i &lt; n - <span class="number">1</span>;i++)&#123;</div><div class="line">		v = a[i];</div><div class="line">		int j = i - <span class="number">1</span>;</div><div class="line">		<span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; v)&#123;</div><div class="line">			a[j + <span class="number">1</span>] = a[j];</div><div class="line">			j--;</div><div class="line">		&#125;</div><div class="line">		a[j + <span class="number">1</span>] = v;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//改进插入排序，往前插入时进行二分查找</span></div><div class="line"><span class="comment">//平均性能更快，时间复杂度降至O(NlogN)</span></div><div class="line"><span class="keyword">void</span> InsertBinarySort(int arr[n],int len)&#123;</div><div class="line">	<span class="keyword">for</span>(int i = <span class="number">1</span>;i &lt; len;i++)&#123;</div><div class="line">		<span class="keyword">if</span>(arr[i] &lt; arr[i - <span class="number">1</span>])&#123;</div><div class="line">			int temp = arr[i];</div><div class="line">			int low = <span class="number">0</span>;</div><div class="line">			int high = i - <span class="number">1</span>;</div><div class="line">			<span class="keyword">while</span>(low &lt;= high)&#123;</div><div class="line">				mid = (low + high) / <span class="number">2</span>;</div><div class="line">				<span class="keyword">if</span>(temp &lt; arr[mid])&#123;</div><div class="line">					high = mid - <span class="number">1</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span>&#123;</div><div class="line">					low = mid + <span class="number">1</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">for</span>(int j = i;j &gt; low;j--)&#123;</div><div class="line">				arr[j] = arr[j - <span class="number">1</span>];</div><div class="line">			&#125;</div><div class="line">			arr[low] = temp;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>算法思想：对冒泡排序的改进，一般从第一个元素开始，将比它小的元素放在前面，比它大的元素放在后面。</p>
<p>一趟快排的算法：</p>
<p>1.从数列中挑出一个元素，称为 “基准”（pivot/key）</p>
<p>2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</p>
<p>3.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> sort(int *a, int left, int right)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="comment">/*如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了*/</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line">    int i = left;</div><div class="line">    int j = right;</div><div class="line">    int key = a[left];</div><div class="line">     </div><div class="line">    <span class="keyword">while</span>(i &lt; j)                               <span class="comment">/*控制在当组内寻找一遍*/</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &lt;= a[j])</div><div class="line">        <span class="comment">/*而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升</span></div><div class="line">        序还是降序）2，没有符合条件1的，并且i与j的大小没有反转*/ </div><div class="line">        &#123;</div><div class="line">            j--;<span class="comment">/*向前寻找*/</span></div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        a[i] = a[j];</div><div class="line">        <span class="comment">/*找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是</span></div><div class="line">        a[left]，那么就是给key）*/</div><div class="line">         </div><div class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &gt;= a[i])</div><div class="line">        <span class="comment">/*这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反，</span></div><div class="line">        因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反*/</div><div class="line">        &#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        a[j] = a[i];</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    a[i] = key;<span class="comment">/*当在当组内找完一遍以后就把中间数key回归*/</span></div><div class="line">    sort(a, left, i - <span class="number">1</span>);<span class="comment">/*最后用同样的方式对分出来的左边的小组进行同上的做法*/</span></div><div class="line">    sort(a, i + <span class="number">1</span>, right);<span class="comment">/*用同样的方式对分出来的右边的小组进行同上的做法*/</span></div><div class="line">                       <span class="comment">/*当然最后可能会出现很多分左右，直到每一组的i = j 为止*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="不常用的"><a href="#不常用的" class="headerlink" title="不常用的"></a>不常用的</h2><p>贴个源码以防我以后想看</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> HAdjust(ElemTp R[], int i, int n) <span class="comment">//避免swap</span></div><div class="line">&#123; </div><div class="line">	int temp=R[i]; </div><div class="line">	int key=temp;</div><div class="line">	int j,iL,iR;</div><div class="line">	<span class="keyword">while</span>(i&lt;=n/<span class="number">2</span><span class="number">-1</span>) <span class="comment">//叶子停止，非叶子继续</span></div><div class="line">	&#123; </div><div class="line">		iL=<span class="number">2</span>*i+<span class="number">1</span>; iR=iL+<span class="number">1</span>; <span class="comment">//求R[i]的左/右儿子下标</span></div><div class="line">		j=iL; <span class="comment">//j为R[i]要交换的结点下标</span></div><div class="line">		<span class="keyword">if</span>(iR&lt;n&amp;&amp;iR&gt;iL) j=iR;</div><div class="line">		<span class="keyword">if</span>(key&gt;R[j]) <span class="keyword">break</span>; <span class="comment">//根结点最大则结束调整</span></div><div class="line">		R[i]=R[j]; i=j;</div><div class="line">	&#125;</div><div class="line">	R[i]=temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> HeapSort(ElemTp R[], int n)</div><div class="line">&#123; <span class="comment">//初始建大根堆</span></div><div class="line">	<span class="keyword">for</span>(int i=n/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) </div><div class="line">		HAdjust(R, i, n);</div><div class="line">	<span class="keyword">for</span>(int i=<span class="number">1</span>; i&lt;n; i++)</div><div class="line">	&#123; </div><div class="line">		swap(R[<span class="number">0</span>], R[n-i]);</div><div class="line">		HAdjust(R, <span class="number">0</span>, n-i);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> ShellSort(ElemTp R[], int n, int d[], int m)</div><div class="line"><span class="comment">// R[0..n-1]升序排序, d[0..m-1]为递减的增量</span></div><div class="line">&#123; </div><div class="line">	int j,e,key,t;</div><div class="line">	<span class="keyword">for</span>(int s=<span class="number">0</span>; s&lt;m; s++) <span class="comment">//m趟剩余类分组插入排序</span></div><div class="line">		<span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;d[s]; i++) <span class="comment">//模d[s]余i类插入排序</span></div><div class="line">			<span class="keyword">for</span>(j=i+d[s]; j&lt;n; j+=d[s])</div><div class="line">			&#123; </div><div class="line">				e=R[j]; </div><div class="line">				key=R[j];</div><div class="line">				<span class="keyword">for</span>(t=j-d[s]; t&gt;=i&amp;&amp;R[t]&gt;key; t-=d[s])</div><div class="line">					R[t+d[s]]=R[t];</div><div class="line">                R[t+d[s]]=e;</div><div class="line">			&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> merge(ElemTp p[], int s, int m, int t, ElemTp q[])</div><div class="line"><span class="comment">//p[s..m]已升序; p[m+1..t]已升序(smt)</span></div><div class="line"><span class="comment">//归并p[s..m]和p[m+1..t], 结果存于q[s..t], 使q[s..t]升序</span></div><div class="line">&#123; </div><div class="line">	int i=s; </div><div class="line">	int j=m+<span class="number">1</span>; </div><div class="line">	int k=s;</div><div class="line">	<span class="keyword">while</span>(i&lt;=m&amp;&amp;j&lt;=t)</div><div class="line">		<span class="keyword">if</span>(p[i]&lt;=p[j]) q[k++]=p[i++];</div><div class="line">		<span class="keyword">else</span> q[k++]=p[j++]; <span class="comment">//用&lt;=是稳定的, 用&lt;不稳定</span></div><div class="line">	<span class="keyword">while</span>(i&lt;=m) q[k++]=p[i++];</div><div class="line">	<span class="keyword">while</span>(j&lt;=t) q[k++]=p[j++];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> MergeSort(ElemTp R[], int n)</div><div class="line">&#123; </div><div class="line">	ElemTp *p=R, *A=<span class="keyword">new</span> ElemTp[n], *q=A; int w, s, m, t;</div><div class="line">	<span class="keyword">for</span>(w=<span class="number">1</span>; w&lt;n; w*=<span class="number">2</span>) <span class="comment">//w为每趟分块长度</span></div><div class="line">	&#123; </div><div class="line">		<span class="keyword">for</span>(s=<span class="number">0</span>; s&lt;n; s+=<span class="number">2</span>*w)</div><div class="line">		&#123; </div><div class="line">			m=min(n<span class="number">-1</span>, s+w<span class="number">-1</span>); </div><div class="line">			t=min(n<span class="number">-1</span>, m+w);</div><div class="line">			merge(p, s, m, t, q);</div><div class="line">		&#125;</div><div class="line">		swap(p, q); <span class="comment">//交换使p为归并源, q为归并目标</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(p==A) </div><div class="line">		<span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;n; i++) R[i]=A[i];</div><div class="line">	<span class="keyword">delete</span> []A; <span class="comment">//删除辅助数组A</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h2><p>顺便用下markdown表格</p>
<table>
<thead>
<tr>
<th style="text-align:center">Algorithm</th>
<th style="text-align:center">Average</th>
<th style="text-align:center">Best</th>
<th style="text-align:center">Worst</th>
<th style="text-align:center">extra space</th>
<th style="text-align:center">stable</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">直接插入排序</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">简单选择排序</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">折半插入排序</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(logN)~O(N^2)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
</tbody>
</table>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>写了差不多三分之一的样子，我要去跑步了，我再不跑步可能就要死了，明天再更新下，嗯我也不知道我在自言自语什么东西，但是今天遇到一个宇宙BUG，我要拿框框记下来。  <em>—-10-13</em></p>
<p>手写了四个算法常用算法，感觉面试应该没问题了，贴了几个不常用的排序以防我以后要看，虽然我知道我应该是不会看的。 <em>—-10-15更新</em></p>
<blockquote><p>当遇到百思不得其解的编译错误，试下把tab换成四下空格，对的没错就是这么无解。</p>
<footer><strong>Yucheng Fang</strong><cite>Bug log</cite></footer></blockquote>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://yoursite.com/2016/10/12/hello-world/</url>
      <content type="html"><![CDATA[<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>过去的一两个月一直在各种笔试、面试中疲于奔命，有喜有忧，情绪起伏不定，想做的太多以至于常常四处尝试，然而发现知道的越多不知道的就越多，今天忙了半天时间开启了Hexo的大门，想起先前无来由的膨胀觉得十分幽默。</p>
<a id="more"></a>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>昨天4399的面试经历让我意识到企业需要的应届生是什么样子的，平心而论玩轮子十分简单，语言基础还是要好好打，不要下次突然被问到指针和引用的区别一脸懵逼。</p>
<p>纪念一下猝不及防让写的二分查找，由于脑袋一片空白写了一个递归，回家发现居然写对了，感觉自己还是有一点….天赋？不过也是时候把常用算法搞一遍了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearchRecursion</span><span class="params">(<span class="keyword">int</span> arry[],<span class="keyword">int</span> value,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(low &gt; high)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span>(arry[mid] == value)</div><div class="line">        <span class="keyword">return</span> mid;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value &lt; arry[mid])</div><div class="line">        <span class="keyword">return</span>    BinarySearchRecursion(arry,value,low,mid - <span class="number">1</span>);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span>    BinarySearchRecursion(arry,value,mid + <span class="number">1</span>,high);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>看了一个下午又瞎又饿，刚开始用MD，感觉还行，插件将后续装上。<br>路漫漫其修远兮~</p>
]]></content>
    </entry>
    
  
  
</search>
