<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[多余部分省略为点点点]]></title>
      <url>http://yoursite.com/2016/10/17/css-1/</url>
      <content type="html"><![CDATA[<h2 id="多余部分省略解决方案"><a href="#多余部分省略解决方案" class="headerlink" title="多余部分省略解决方案"></a>多余部分省略解决方案</h2><p>今天笔试勤智数码遇到的问题，没有答出来，回来总结一下。</p>
<h3 id="单行"><a href="#单行" class="headerlink" title="单行"></a>单行</h3><p>CSS就能实现，挺简单的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.test&#123;</div><div class="line">		<span class="attr">width</span>: <span class="number">50</span>px;</div><div class="line">		overflow: hidden;</div><div class="line">		text-overflow: ellipsis;</div><div class="line">		white-space: nowrap;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h3 id="WebKit浏览器或移动端的页面"><a href="#WebKit浏览器或移动端的页面" class="headerlink" title="WebKit浏览器或移动端的页面"></a>WebKit浏览器或移动端的页面</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.test&#123;</div><div class="line">		<span class="attr">overflow</span> : hidden;</div><div class="line">		text-overflow: ellipsis;</div><div class="line">		display: -webkit-box;</div><div class="line">		-webkit-line-clamp: <span class="number">2</span>;</div><div class="line">		-webkit-box-orient: vertical;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="跨浏览器兼容方案"><a href="#跨浏览器兼容方案" class="headerlink" title="跨浏览器兼容方案"></a>跨浏览器兼容方案</h3><p>比较靠谱简单的做法就是设置相对定位的容器高度，用包含省略号(…)的元素模拟实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">p &#123;</div><div class="line">    <span class="attr">position</span>:relative;</div><div class="line">    line-height:<span class="number">1.4</span>em;</div><div class="line">    <span class="comment">/* 3 times the line-height to show 3 lines */</span></div><div class="line">    height:<span class="number">4.2</span>em;</div><div class="line">    overflow:hidden;</div><div class="line">&#125;</div><div class="line">p::after &#123;</div><div class="line">    <span class="attr">content</span>:<span class="string">"..."</span>;</div><div class="line">    font-weight:bold;</div><div class="line">    position:absolute;</div><div class="line">    bottom:<span class="number">0</span>;</div><div class="line">    right:<span class="number">0</span>;</div><div class="line">    padding:<span class="number">0</span> <span class="number">20</span>px <span class="number">1</span>px <span class="number">45</span>px;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="黑科技"><a href="#黑科技" class="headerlink" title="黑科技"></a>黑科技</h3><p>插件<a href="http://dotdotdot.frebsite.nl" target="_blank" rel="external">jQuery.dotdotdot</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	$(<span class="string">"#wrapper"</span>).dotdotdot(&#123;</div><div class="line">		<span class="comment">//	configuration goes here</span></div><div class="line">	&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>转自<a href="http://blog.csdn.net/fanhu6816/article/details/52063758" target="_blank" rel="external">博客</a>，有更为详细的总结</p>
<h2 id="明天要做的事情"><a href="#明天要做的事情" class="headerlink" title="明天要做的事情"></a>明天要做的事情</h2><ul>
<li>信息安全小测</li>
<li>研究Express框架</li>
<li>总结SEO、分页相关知识</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一些排序算法]]></title>
      <url>http://yoursite.com/2016/10/13/algorithm-sort/</url>
      <content type="html"><![CDATA[<h2 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>算法思想：对n个元素的序列进行n-1趟的排序。第一趟排序对序列进行从头到尾的扫描，找到最小的元素与第一个元素交换，第二趟排序对序列从第二个元素起到序列尾扫描，找到最小元素与第二个元素交换，以此类推。<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> SelectionSort(int a[n])&#123;</div><div class="line">	<span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++)&#123;</div><div class="line">		int min = i;</div><div class="line">		<span class="keyword">for</span>(int j = i + <span class="number">1</span>;j &lt; n - <span class="number">1</span>;j++)</div><div class="line">			<span class="keyword">if</span>(a[min] &gt; a[j]) min = j;</div><div class="line">		swap(a[min],a[i]);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>算法思想：对有n个元素的序列进行n-1趟排序，相邻元素逆序则交换。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> BubbleSort(int a[n])&#123;</div><div class="line">	<span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)&#123;</div><div class="line">		<span class="comment">//改进算法，如果一趟未逆序则已经有序</span></div><div class="line">		<span class="comment">//bool exchange = true;</span></div><div class="line">		<span class="keyword">for</span>(int j = <span class="number">0</span>;j &lt; n-i<span class="number">-1</span>;j++)&#123;</div><div class="line">			<span class="keyword">if</span>(a[j + <span class="number">1</span>] &lt; a[j])&#123;</div><div class="line">				swap(a[j],a[j + <span class="number">1</span>]);</div><div class="line">				<span class="comment">//exchange = false;</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(exchange)&#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>算法思想：将数据插入已经排好序的有序数据中，本质上属于减治策略。</p>
<blockquote>
<p>关于减治策略：减治技术利用一个问题给定实例的解和同样问题较小的实例的解中的某种关系。一旦建立了这种关系，就可以采取递归手段。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> InsertSort(int a[n])&#123;</div><div class="line">	<span class="comment">//将数列第一个元素减去，当成一个数列</span></div><div class="line">	<span class="keyword">for</span>(int i = <span class="number">1</span>;i &lt; n - <span class="number">1</span>;i++)&#123;</div><div class="line">		v = a[i];</div><div class="line">		int j = i - <span class="number">1</span>;</div><div class="line">		<span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; v)&#123;</div><div class="line">			a[j + <span class="number">1</span>] = a[j];</div><div class="line">			j--;</div><div class="line">		&#125;</div><div class="line">		a[j + <span class="number">1</span>] = v;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//改进插入排序，往前插入时进行二分查找</span></div><div class="line"><span class="comment">//平均性能更快，时间复杂度降至O(NlogN)</span></div><div class="line"><span class="keyword">void</span> InsertBinarySort(int arr[n],int len)&#123;</div><div class="line">	<span class="keyword">for</span>(int i = <span class="number">1</span>;i &lt; len;i++)&#123;</div><div class="line">		<span class="keyword">if</span>(arr[i] &lt; arr[i - <span class="number">1</span>])&#123;</div><div class="line">			int temp = arr[i];</div><div class="line">			int low = <span class="number">0</span>;</div><div class="line">			int high = i - <span class="number">1</span>;</div><div class="line">			<span class="keyword">while</span>(low &lt;= high)&#123;</div><div class="line">				mid = (low + high) / <span class="number">2</span>;</div><div class="line">				<span class="keyword">if</span>(temp &lt; arr[mid])&#123;</div><div class="line">					high = mid - <span class="number">1</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span>&#123;</div><div class="line">					low = mid + <span class="number">1</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">for</span>(int j = i;j &gt; low;j--)&#123;</div><div class="line">				arr[j] = arr[j - <span class="number">1</span>];</div><div class="line">			&#125;</div><div class="line">			arr[low] = temp;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>算法思想：对冒泡排序的改进，一般从第一个元素开始，将比它小的元素放在前面，比它大的元素放在后面。</p>
<p>一趟快排的算法：</p>
<p>1.从数列中挑出一个元素，称为 “基准”（pivot/key）</p>
<p>2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</p>
<p>3.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> sort(int *a, int left, int right)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="comment">/*如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了*/</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line">    int i = left;</div><div class="line">    int j = right;</div><div class="line">    int key = a[left];</div><div class="line">     </div><div class="line">    <span class="keyword">while</span>(i &lt; j)                               <span class="comment">/*控制在当组内寻找一遍*/</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &lt;= a[j])</div><div class="line">        <span class="comment">/*而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升</span></div><div class="line">        序还是降序）2，没有符合条件1的，并且i与j的大小没有反转*/ </div><div class="line">        &#123;</div><div class="line">            j--;<span class="comment">/*向前寻找*/</span></div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        a[i] = a[j];</div><div class="line">        <span class="comment">/*找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是</span></div><div class="line">        a[left]，那么就是给key）*/</div><div class="line">         </div><div class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &gt;= a[i])</div><div class="line">        <span class="comment">/*这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反，</span></div><div class="line">        因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反*/</div><div class="line">        &#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        a[j] = a[i];</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    a[i] = key;<span class="comment">/*当在当组内找完一遍以后就把中间数key回归*/</span></div><div class="line">    sort(a, left, i - <span class="number">1</span>);<span class="comment">/*最后用同样的方式对分出来的左边的小组进行同上的做法*/</span></div><div class="line">    sort(a, i + <span class="number">1</span>, right);<span class="comment">/*用同样的方式对分出来的右边的小组进行同上的做法*/</span></div><div class="line">                       <span class="comment">/*当然最后可能会出现很多分左右，直到每一组的i = j 为止*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="不常用的"><a href="#不常用的" class="headerlink" title="不常用的"></a>不常用的</h2><p>贴个源码以防我以后想看</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> HAdjust(ElemTp R[], int i, int n) <span class="comment">//避免swap</span></div><div class="line">&#123; </div><div class="line">	int temp=R[i]; </div><div class="line">	int key=temp;</div><div class="line">	int j,iL,iR;</div><div class="line">	<span class="keyword">while</span>(i&lt;=n/<span class="number">2</span><span class="number">-1</span>) <span class="comment">//叶子停止，非叶子继续</span></div><div class="line">	&#123; </div><div class="line">		iL=<span class="number">2</span>*i+<span class="number">1</span>; iR=iL+<span class="number">1</span>; <span class="comment">//求R[i]的左/右儿子下标</span></div><div class="line">		j=iL; <span class="comment">//j为R[i]要交换的结点下标</span></div><div class="line">		<span class="keyword">if</span>(iR&lt;n&amp;&amp;iR&gt;iL) j=iR;</div><div class="line">		<span class="keyword">if</span>(key&gt;R[j]) <span class="keyword">break</span>; <span class="comment">//根结点最大则结束调整</span></div><div class="line">		R[i]=R[j]; i=j;</div><div class="line">	&#125;</div><div class="line">	R[i]=temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> HeapSort(ElemTp R[], int n)</div><div class="line">&#123; <span class="comment">//初始建大根堆</span></div><div class="line">	<span class="keyword">for</span>(int i=n/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) </div><div class="line">		HAdjust(R, i, n);</div><div class="line">	<span class="keyword">for</span>(int i=<span class="number">1</span>; i&lt;n; i++)</div><div class="line">	&#123; </div><div class="line">		swap(R[<span class="number">0</span>], R[n-i]);</div><div class="line">		HAdjust(R, <span class="number">0</span>, n-i);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> ShellSort(ElemTp R[], int n, int d[], int m)</div><div class="line"><span class="comment">// R[0..n-1]升序排序, d[0..m-1]为递减的增量</span></div><div class="line">&#123; </div><div class="line">	int j,e,key,t;</div><div class="line">	<span class="keyword">for</span>(int s=<span class="number">0</span>; s&lt;m; s++) <span class="comment">//m趟剩余类分组插入排序</span></div><div class="line">		<span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;d[s]; i++) <span class="comment">//模d[s]余i类插入排序</span></div><div class="line">			<span class="keyword">for</span>(j=i+d[s]; j&lt;n; j+=d[s])</div><div class="line">			&#123; </div><div class="line">				e=R[j]; </div><div class="line">				key=R[j];</div><div class="line">				<span class="keyword">for</span>(t=j-d[s]; t&gt;=i&amp;&amp;R[t]&gt;key; t-=d[s])</div><div class="line">					R[t+d[s]]=R[t];</div><div class="line">                R[t+d[s]]=e;</div><div class="line">			&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> merge(ElemTp p[], int s, int m, int t, ElemTp q[])</div><div class="line"><span class="comment">//p[s..m]已升序; p[m+1..t]已升序(smt)</span></div><div class="line"><span class="comment">//归并p[s..m]和p[m+1..t], 结果存于q[s..t], 使q[s..t]升序</span></div><div class="line">&#123; </div><div class="line">	int i=s; </div><div class="line">	int j=m+<span class="number">1</span>; </div><div class="line">	int k=s;</div><div class="line">	<span class="keyword">while</span>(i&lt;=m&amp;&amp;j&lt;=t)</div><div class="line">		<span class="keyword">if</span>(p[i]&lt;=p[j]) q[k++]=p[i++];</div><div class="line">		<span class="keyword">else</span> q[k++]=p[j++]; <span class="comment">//用&lt;=是稳定的, 用&lt;不稳定</span></div><div class="line">	<span class="keyword">while</span>(i&lt;=m) q[k++]=p[i++];</div><div class="line">	<span class="keyword">while</span>(j&lt;=t) q[k++]=p[j++];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> MergeSort(ElemTp R[], int n)</div><div class="line">&#123; </div><div class="line">	ElemTp *p=R, *A=<span class="keyword">new</span> ElemTp[n], *q=A; int w, s, m, t;</div><div class="line">	<span class="keyword">for</span>(w=<span class="number">1</span>; w&lt;n; w*=<span class="number">2</span>) <span class="comment">//w为每趟分块长度</span></div><div class="line">	&#123; </div><div class="line">		<span class="keyword">for</span>(s=<span class="number">0</span>; s&lt;n; s+=<span class="number">2</span>*w)</div><div class="line">		&#123; </div><div class="line">			m=min(n<span class="number">-1</span>, s+w<span class="number">-1</span>); </div><div class="line">			t=min(n<span class="number">-1</span>, m+w);</div><div class="line">			merge(p, s, m, t, q);</div><div class="line">		&#125;</div><div class="line">		swap(p, q); <span class="comment">//交换使p为归并源, q为归并目标</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(p==A) </div><div class="line">		<span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;n; i++) R[i]=A[i];</div><div class="line">	<span class="keyword">delete</span> []A; <span class="comment">//删除辅助数组A</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h2><p>顺便用下markdown表格</p>
<table>
<thead>
<tr>
<th style="text-align:center">Algorithm</th>
<th style="text-align:center">Average</th>
<th style="text-align:center">Best</th>
<th style="text-align:center">Worst</th>
<th style="text-align:center">extra space</th>
<th style="text-align:center">stable</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">直接插入排序</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">简单选择排序</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">折半插入排序</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(logN)~O(N^2)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(NlogN)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
</tbody>
</table>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>写了差不多三分之一的样子，我要去跑步了，我再不跑步可能就要死了，明天再更新下，嗯我也不知道我在自言自语什么东西，但是今天遇到一个宇宙BUG，我要拿框框记下来。  <em>—-10-13</em></p>
<p>手写了四个算法常用算法，感觉面试应该没问题了，贴了几个不常用的排序以防我以后要看，虽然我知道我应该是不会看的。 <em>—-10-15更新</em></p>
<blockquote><p>当遇到百思不得其解的编译错误，试下把tab换成四下空格，对的没错就是这么无解。</p>
<footer><strong>Yucheng Fang</strong><cite>Bug log</cite></footer></blockquote>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://yoursite.com/2016/10/12/hello-world/</url>
      <content type="html"><![CDATA[<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>过去的一两个月一直在各种笔试、面试中疲于奔命，有喜有忧，情绪起伏不定，想做的太多以至于常常四处尝试，然而发现知道的越多不知道的就越多，今天忙了半天时间开启了Hexo的大门，想起先前无来由的膨胀觉得十分幽默。</p>
<a id="more"></a>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>昨天4399的面试经历让我意识到企业需要的应届生是什么样子的，平心而论玩轮子十分简单，语言基础还是要好好打，不要下次突然被问到指针和引用的区别一脸懵逼。</p>
<p>纪念一下猝不及防让写的二分查找，由于脑袋一片空白写了一个递归，回家发现居然写对了，感觉自己还是有一点….天赋？不过也是时候把常用算法搞一遍了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearchRecursion</span><span class="params">(<span class="keyword">int</span> arry[],<span class="keyword">int</span> value,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(low &gt; high)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span>(arry[mid] == value)</div><div class="line">        <span class="keyword">return</span> mid;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value &lt; arry[mid])</div><div class="line">        <span class="keyword">return</span>    BinarySearchRecursion(arry,value,low,mid - <span class="number">1</span>);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span>    BinarySearchRecursion(arry,value,mid + <span class="number">1</span>,high);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>看了一个下午又瞎又饿，刚开始用MD，感觉还行，插件将后续装上。<br>路漫漫其修远兮~</p>
]]></content>
    </entry>
    
  
  
</search>
